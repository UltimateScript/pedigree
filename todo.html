<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>The Pedigree Project: Todo List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">The Pedigree Project
   &#160;<span id="projectnumber">0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Todo <a class="el" href="classList.html">List</a> </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt><a class="anchor" id="_todo000430"></a>Member <a class="el" href="classARM926EInterruptManager.html#a7e21ed2032fc8dce3a325c1e1198306c">ARM926EInterruptManager::initialiseProcessor</a>  ()</dt>
<dd>and some smp/acpi function  </dd>
<dt><a class="anchor" id="_todo000429"></a>Member <a class="el" href="classARM926EInterruptManager.html#a556f4ab37c834e6efc04fe541bcd55d3">ARM926EInterruptManager::syscall</a>  (Service_t service, uintptr_t function, uintptr_t p1=0, uintptr_t p2=0, uintptr_t p3=0, uintptr_t p4=0, uintptr_t p5=0)</dt>
<dd>Software interrupt  </dd>
<dt><a class="anchor" id="_todo000440"></a>Class <a class="el" href="structArm926EVirtualAddressSpace_1_1FirstLevelDescriptor__Section_1_1Desc.html">Arm926EVirtualAddressSpace::FirstLevelDescriptor_Section::Desc</a>  </dt>
<dd>this does not add up to 31 or 32... :S  </dd>
<dt><a class="anchor" id="_todo000436"></a>Class <a class="el" href="structArm926EVirtualAddressSpace_1_1Translation.html">Arm926EVirtualAddressSpace::Translation</a>  </dt>
<dd>I don't think all this belongs here. Put here to get the structures then read up on how PPC does it.  </dd>
<dt><a class="anchor" id="_todo000524"></a>Member <a class="el" href="classArmBeagleSerial.html#ad4473fa0cbed41a968da19babd6b34d6">ArmBeagleSerial::interrupt</a>  (size_t nInterruptNumber, InterruptState &amp;state)</dt>
<dd><p class="startdd">Queue somewhere for input </p>
<p>Handle </p>
<p class="enddd">Handle  </p>
</dd>
<dt><a class="anchor" id="_todo000523"></a>Member <a class="el" href="classArmBeagleSerial.html#ab8788d5b8847b6d764d432d897b8a495">ArmBeagleSerial::setBase</a>  (uintptr_t nBaseAddr)</dt>
<dd>this is the UART3 IRQ... needs to be set for each UART  </dd>
<dt><a class="anchor" id="_todo000445"></a>Member <a class="el" href="classARMV7InterruptManager.html#a6c67923a4dab6dee4a4d8ae291141ce0">ARMV7InterruptManager::initialiseProcessor</a>  ()</dt>
<dd>and some smp/acpi function  </dd>
<dt><a class="anchor" id="_todo000441"></a>Member <a class="el" href="classARMV7InterruptManager.html#a2233dd619dcd53b52b2782d6798c793a">ARMV7InterruptManager::registerInterruptHandler</a>  (size_t interruptNumber, <a class="el" href="classInterruptHandler.html" title="Abstract base class for interrupt-handlers. ">InterruptHandler</a> *handler)</dt>
<dd><p class="startdd">This is very machine-specific... </p>
<p class="enddd">Needs locking  </p>
</dd>
<dt><a class="anchor" id="_todo000443"></a>Member <a class="el" href="classARMV7InterruptManager.html#a24918d9ad440194f79fcb4805a920e49">ARMV7InterruptManager::registerInterruptHandlerDebugger</a>  (size_t interruptNumber, <a class="el" href="classInterruptHandler.html" title="Abstract base class for interrupt-handlers. ">InterruptHandler</a> *handler)</dt>
<dd>Needs locking  </dd>
<dt><a class="anchor" id="_todo000444"></a>Member <a class="el" href="classARMV7InterruptManager.html#a6bb69e7007bee7ac72222443f4d86e24">ARMV7InterruptManager::syscall</a>  (Service_t service, uintptr_t function, uintptr_t p1=0, uintptr_t p2=0, uintptr_t p3=0, uintptr_t p4=0, uintptr_t p5=0)</dt>
<dd>Software interrupt  </dd>
<dt><a class="anchor" id="_todo000394"></a>Member <a class="el" href="classARMV7InterruptState.html#ace7f61c310a4a04f8b70acc791d42b48">ARMV7InterruptState::getInterruptNumber</a>  () const </dt>
<dd>implement  </dd>
<dt><a class="anchor" id="_todo000396"></a>Member <a class="el" href="classARMV7InterruptState.html#ab6e9f3b4fe802e3708996d366f301107">ARMV7InterruptState::getSyscallNumber</a>  () const </dt>
<dd>implement  </dd>
<dt><a class="anchor" id="_todo000395"></a>Member <a class="el" href="classARMV7InterruptState.html#a443b7823d7d73f48b87c5fb542e5c29a">ARMV7InterruptState::getSyscallService</a>  () const </dt>
<dd>implement  </dd>
<dt><a class="anchor" id="_todo000458"></a>Member <a class="el" href="classArmV7KernelVirtualAddressSpace.html#abcf599890883de588e1b59f4b10edee3">ArmV7KernelVirtualAddressSpace::initialiseKernelAddressSpace</a>  ()</dt>
<dd>Correct flags  </dd>
<dt><a class="anchor" id="_todo000457"></a>Member <a class="el" href="classArmV7KernelVirtualAddressSpace.html#a72635055efdd0410b185f588073c24ef">ArmV7KernelVirtualAddressSpace::m_Instance</a>  </dt>
<dd>MAX_PROCESSORS  </dd>
<dt><a class="anchor" id="_todo000447"></a>Member <a class="el" href="classArmV7PhysicalMemoryManager.html#acf604ea21ce386c1c56973cb592df6b6">ArmV7PhysicalMemoryManager::allocatePage</a>  ()</dt>
<dd><a class="el" href="classCache.html">Cache</a> compact if needed  </dd>
<dt><a class="anchor" id="_todo000448"></a>Member <a class="el" href="classArmV7PhysicalMemoryManager.html#ad6dfcc9fbfe13161bb138661f9fb0460">ArmV7PhysicalMemoryManager::pin</a>  (physical_uintptr_t page)</dt>
<dd>Implement <a class="el" href="classArmV7PhysicalMemoryManager.html#ad6dfcc9fbfe13161bb138661f9fb0460">pin()</a>  </dd>
<dt><a class="anchor" id="_todo000456"></a>Member <a class="el" href="classARMV7StackFrame.html#a1523bc295e5078ac0ff704ce3e962e69">ARMV7StackFrame::getParameter</a>  (size_t n)</dt>
<dd>Write.  </dd>
<dt><a class="anchor" id="_todo000527"></a>Member <a class="el" href="classArmVersatile.html#a353e62db20200390887b8854300d6cea">ArmVersatile::initialise</a>  ()</dt>
<dd>setup second pl011 as well (removed to make it work) and detect existance of pl011s  </dd>
<dt><a class="anchor" id="_todo000007"></a>Member <a class="el" href="classAtaDisk.html#a931998a76f0ddabb606e5b2bf25054bf">AtaDisk::doRead</a>  (uint64_t location)</dt>
<dd><p class="startdd">getPageSize() here </p>
<p>logical sector size here </p>
<p>What's the best way to handle this? </p>
<p class="enddd">What's the best way to handle this?  </p>
</dd>
<dt><a class="anchor" id="_todo000011"></a>Member <a class="el" href="classAtaDisk.html#a61b036e93c5755f0187e1a7cdb133be1">AtaDisk::doWrite</a>  (uint64_t location)</dt>
<dd><p class="startdd">might still want to allow writes - assuming CDROM here... </p>
<p>logical sector size here </p>
<p>What's the best way to handle this? </p>
<p class="enddd">What's the best way to handle this?  </p>
</dd>
<dt><a class="anchor" id="_todo000004"></a>Member <a class="el" href="classAtaDisk.html#a7669522ad06e41f75f4557fd4e517687">AtaDisk::initialise</a>  (size_t nUnit=~0)</dt>
<dd><p class="startdd">should check that this doesn't break on ATAPI </p>
<p class="enddd">Testing needs to be done on more than just CD/DVD and block devices...  </p>
</dd>
<dt><a class="anchor" id="_todo000015"></a>Member <a class="el" href="classAtaDisk.html#a23aaa26a0678cf39c617bbdac1046342">AtaDisk::m_IrqReceived</a>  </dt>
<dd>A condvar would really be better here.  </dd>
<dt><a class="anchor" id="_todo000006"></a>Member <a class="el" href="classAtaDisk.html#a8c2e3645e12cd322748f79e73de6b368">AtaDisk::sendCommand</a>  (size_t nUnit, uintptr_t pCommand, uint8_t nCommandSize, uintptr_t pRespBuffer, uint16_t nRespBytes, bool bWrite)</dt>
<dd>What's the best way to handle this?  </dd>
<dt><a class="anchor" id="_todo000386"></a>Member <a class="el" href="classBeagleGpio.html#a3776b7303d95187d3b18365f5ea48d5d">BeagleGpio::initspecific</a>  (int n, volatile unsigned int *gpio)</dt>
<dd>When implementing within Pedigree, we'll have a much nicer interface for string manipulation and writing stuff to the UART.  </dd>
<dt><a class="anchor" id="_todo000553"></a>Member <a class="el" href="classBuffer.html#a65f6724c195329a3ae3fafa1ad28143f">Buffer&lt; T, allowShortOperation &gt;::canRead</a>  (bool block)</dt>
<dd>handle errors better  </dd>
<dt><a class="anchor" id="_todo000016"></a>Member <a class="el" href="classBusMasterIde.html#a3ef48369b4012c093137a685e7139df9">BusMasterIde::add</a>  (uintptr_t buffer, size_t nBytes)</dt>
<dd>Can't write if a read is in progress, and vice versa  </dd>
<dt><a class="anchor" id="_todo000017"></a>Member <a class="el" href="unionBusMasterIdeCommandRegister.html#aafd4bf613a18e7b4ac0fbcb7fa687050">BusMasterIdeCommandRegister::__attribute__</a>  ((packed)) bits</dt>
<dd>I blanked when writing this, so I can't remember if this defines "bits" as a packed structure or if the attribute is ignored...  </dd>
<dt><a class="anchor" id="_todo000554"></a>Member <a class="el" href="classCache.html#a54f7b84d141953a59fea124497afe432">Cache::insert</a>  (uintptr_t key, bool *alreadyExisted=nullptr)</dt>
<dd>remove this, it makes the bloom filter pointless  </dd>
<dt><a class="anchor" id="_todo000555"></a>Member <a class="el" href="classCache.html#a93a267e70a1010cef13b62a5c0b25983">Cache::insert</a>  (uintptr_t key, size_t size, bool *alreadyExisted=nullptr)</dt>
<dd>no - this doesn't check the full size!  </dd>
<dt><a class="anchor" id="_todo000556"></a>Member <a class="el" href="classCache.html#a5e2cbc66e8c1d8709ea556ab2c973e36">Cache::timer</a>  (uint64_t delta, InterruptState &amp;state)</dt>
<dd>something with locks  </dd>
<dt><a class="anchor" id="_todo000027"></a>Member <a class="el" href="classCdiDisk.html#aeae5abcd309724503c75a0ffa87b54be">CdiDisk::flush</a>  (uint64_t location)</dt>
<dd>Fix that.  </dd>
<dt><a class="anchor" id="_todo000029"></a>Member <a class="el" href="classCdiNet.html#a98f05b1b6afa05954c4cbdd0c9bac157">CdiNet::CdiNet</a>  (struct cdi_net_device *device)</dt>
<dd>Check endianness - <em>should</em> be fine, but we'll see...  </dd>
<dt><a class="anchor" id="_todo000028"></a>Member <a class="el" href="classCdiNet.html#a67ff299d843380cb3ce18a909436c43c">CdiNet::CdiNet</a>  (<a class="el" href="classNetwork.html">Network</a> *pDev, struct cdi_net_device *device)</dt>
<dd>Check endianness - <em>should</em> be fine, but we'll see...  </dd>
<dt><a class="anchor" id="_todo000417"></a>Member <a class="el" href="classConditionVariable.html#abd9f7f84df4b8efc7e1f0b0f34a91887">ConditionVariable::wait</a>  (<a class="el" href="classMutex.html">Mutex</a> &amp;mutex, Time::Timestamp &amp;timeout)</dt>
<dd>this is actually buggy as it won't respect the timeout  </dd>
<dt><a class="anchor" id="_todo000273"></a>Member <a class="el" href="classConsoleFile.html#a14614bc13e849ffcf681df6eb77cd573">ConsoleFile::inputLineDiscipline</a>  (char *buf, size_t len, size_t flags=~0U, const char *controlChars=0)</dt>
<dd>remove me, this is because of the port  </dd>
<dt><a class="anchor" id="_todo000272"></a>Member <a class="el" href="classConsolePhysicalFile.html#ae716211a94f4b87f25bc34090bc96c1b">ConsolePhysicalFile::getLast</a>  ()</dt>
<dd>this is no good  </dd>
<dt><a class="anchor" id="_todo000274"></a>Member <a class="el" href="classConsolePhysicalFile.html#a597660017350da9fb6767bca09b3133e">ConsolePhysicalFile::writeBytewise</a>  (uint64_t location, uint64_t size, uintptr_t buffer, bool bCanBlock=true)</dt>
<dd><p class="startdd">handle small writes </p>
<p class="enddd">disciplineSize can be bigger than size due to edits, how do we manage this instead of lying?  </p>
</dd>
<dt><a class="anchor" id="_todo000557"></a>Member <a class="el" href="classCord.html#af14eaa679ddbe1b9b27579eff1b0501f">Cord::operator[]</a>  (size_t index) const </dt>
<dd>should this be more crashy?  </dd>
<dt><a class="anchor" id="_todo000505"></a>Member <a class="el" href="classDebugger.html#a46e97eb061da07891e0aa4cd28368d5c">Debugger::initialise</a>  ()</dt>
<dd>Figure out a way of getting similar functionality  </dd>
<dt><a class="anchor" id="_todo000506"></a>Member <a class="el" href="classDebugger.html#a059ab327ce2ccda742e3a0548f552918">Debugger::start</a>  (InterruptState &amp;state, LargeStaticString &amp;description)</dt>
<dd>OZMFGBARBIE, this needs major cleanup. Look at the state of it!! :O  </dd>
<dt><a class="anchor" id="_todo000390"></a>Member <a class="el" href="classDevice.html#a2723e24ac0d20f58ea6bdfaef621dabf">Device::foreach</a>  (Callback callback, <a class="el" href="classDevice.html">Device</a> *root=0)</dt>
<dd><p class="startdd">add filters to avoid the need to filter in callbacks </p>
<p class="enddd">add a way to end iteration early  </p>
</dd>
<dt><a class="anchor" id="_todo000334"></a><a class="el" href="structModule.html">Module</a> <a class="el" href="group__dhcp4.html">dhcp4</a>  </dt>
<dd>:<ul>
<li>Support for interfaces other than Ethernet (SLIP, PPP, ...) </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000370"></a>Class <a class="el" href="classDirectory.html">Directory</a>  </dt>
<dd>Need to add a way to count # of times a particular lookup has happened so we can potentially offer a way to cull directory entries that are otherwise just consuming space.  </dd>
<dt><a class="anchor" id="_todo000368"></a>Member <a class="el" href="classDirectory.html#a0160fa0fb93f6ff100913fa90cf904e7">Directory::addEphemeralFile</a>  (<a class="el" href="classFile.html">File</a> *pFile)</dt>
<dd>removal will still want to hit the <a class="el" href="classFilesystem.html">Filesystem</a> here! not good!  </dd>
<dt><a class="anchor" id="_todo000369"></a>Member <a class="el" href="classDirectory.html#a23b00c1d0a45d1ac1b7421022b266e15">Directory::destroyEntry</a>  (<a class="el" href="classFile.html">File</a> *file)</dt>
<dd>figure out how to destroy <a class="el" href="classFile.html">File</a> objects!  </dd>
<dt><a class="anchor" id="_todo000367"></a>Member <a class="el" href="classDirectory.html#a7426726ec5606e1f78b8f9691621902b">Directory::remove</a>  (const <a class="el" href="classHashedStringView.html">HashedStringView</a> &amp;s)</dt>
<dd>add sibling keys for other <a class="el" href="classHashTable.html">HashTable</a> functions  </dd>
<dt><a class="anchor" id="_todo000528"></a>Member <a class="el" href="classDisplay.html#a7986cfe3a78c0937ee53a3d165b0ccc4">Display::setScreenMode</a>  (size_t nWidth, size_t nHeight, size_t nBpp)</dt>
<dd>"Closest match": allow a threshold for a match in case the specific mode specified cannot be set.  </dd>
<dt><a class="anchor" id="_todo000033"></a>Member <a class="el" href="classDm9601.html#a4b6f4fac5d984ba6874e948269c2491e">Dm9601::initialiseDriver</a>  ()</dt>
<dd>Timeout  </dd>
<dt><a class="anchor" id="_todo000034"></a>Member <a class="el" href="classDm9601.html#a485faae80e6258d74e1cadb914514d3d">Dm9601::readEeprom</a>  (uint8_t offset)</dt>
<dd>Locking  </dd>
<dt><a class="anchor" id="_todo000036"></a>Member <a class="el" href="classDm9601.html#acbd527bcccf0138edb9d350587bad104">Dm9601::readMii</a>  (uint8_t offset)</dt>
<dd>Locking  </dd>
<dt><a class="anchor" id="_todo000035"></a>Member <a class="el" href="classDm9601.html#a8aea4deff40ca8b75a24b1f745dc7e75">Dm9601::writeEeprom</a>  (uint8_t offset, uint16_t data)</dt>
<dd>Locking  </dd>
<dt><a class="anchor" id="_todo000037"></a>Member <a class="el" href="classDm9601.html#acd7ae0c1cda2fd69ae2b8fbdc6daf5e9">Dm9601::writeMii</a>  (uint8_t offset, uint16_t data)</dt>
<dd>Locking  </dd>
<dt><a class="anchor" id="_todo000388"></a>Member <a class="el" href="classDwarfState.html#af74ac2684c95b5331ad8d7e6d390dc8c">DwarfState::getRegister</a>  (unsigned int nRegister, const <a class="el" href="classDwarfState.html">DwarfState</a> &amp;initialState)</dt>
<dd>This needs to be better - we need to check if the CFA is borked so we don't try to do a stupid read - This requires <a class="el" href="classVirtualAddressSpace.html">VirtualAddressSpace</a>, I think.  </dd>
<dt><a class="anchor" id="_todo000316"></a>Member <a class="el" href="classDynamicLinker.html#a2adbd0c58cd4ca389f042cf771e8f2ca">DynamicLinker::initPlt</a>  (<a class="el" href="classElf.html">Elf</a> *pElf, uintptr_t value)</dt>
<dd><p class="startdd">Change this to use the size of the elf! </p>
<p>Page size here. </p>
<p>Page size here. </p>
<p>ARMify </p>
<p>Change this to use the size of the elf! </p>
<p>Page size here. </p>
<p>Page size here. </p>
<p>Change this to use the size of the elf! </p>
<p>Page size here. </p>
<p class="enddd">Page size here.  </p>
</dd>
<dt><a class="anchor" id="_todo000326"></a>Member <a class="el" href="classDynamicLinker.html#a6653cf7e1fec54a30f5c3dcd40cf55ab">DynamicLinker::resolvePltSymbol</a>  (uintptr_t libraryId, uintptr_t symIdx)</dt>
<dd>Why is there a /4 here?  </dd>
<dt><a class="anchor" id="_todo000048"></a>Member <a class="el" href="classEhci.html#a2bb0bdcc2f048c4315c97b0bf422c8a8">Ehci::initialiseController</a>  ()</dt>
<dd>Handle non-32-bit aligned values for the EECP  </dd>
<dt><a class="anchor" id="_todo000512"></a>Member <a class="el" href="classElf.html#aa7c6020a756cfdc503a2c62c8f032ffb">Elf::allocate</a>  (uint8_t *pBuffer, size_t length, uintptr_t &amp;loadBase, <a class="el" href="classSymbolTable.html">SymbolTable</a> *pSymtab=0, bool bAllocate=true, size_t *pSize=0)</dt>
<dd>Don't rely on this. Look at nchain in the hash table.  </dd>
<dt><a class="anchor" id="_todo000464"></a>Member <a class="el" href="classElf.html#aecff80b06c6e74d53de8f6d3f2ee6086">Elf::applyRelocation</a>  (<a class="el" href="structElf_1_1ElfRela__t.html">ElfRela_t</a> rela, <a class="el" href="structElf_1_1ElfSectionHeader__t.html">ElfSectionHeader_t</a> *pSh, <a class="el" href="classSymbolTable.html">SymbolTable</a> *pSymtab=0, uintptr_t loadBase=0, <a class="el" href="classSymbolTable.html#adead8b071cd36d4cf089cd5f456fe798">SymbolTable::Policy</a> policy=<a class="el" href="classSymbolTable.html#adead8b071cd36d4cf089cd5f456fe798a63b2be0ffb189400427a9a27602aa949">SymbolTable::LocalFirst</a>)</dt>
<dd>Should be A + B?  </dd>
<dt><a class="anchor" id="_todo000513"></a>Member <a class="el" href="classElf.html#a019e7d0d9a5ff4872805e5d02a287b54">Elf::extractEntryPoint</a>  (uint8_t *pBuffer, size_t length, uintptr_t &amp;entry)</dt>
<dd>check magic  </dd>
<dt><a class="anchor" id="_todo000514"></a>Member <a class="el" href="classElf.html#a7cceb5d973dd7e686f27fa113eee7d8f">Elf::extractInformation</a>  (uint8_t *pBuffer, size_t length, size_t &amp;phdrCount, size_t &amp;phdrEntrySize, uintptr_t &amp;phdrAddress)</dt>
<dd>check magic  </dd>
<dt><a class="anchor" id="_todo000510"></a>Member <a class="el" href="classElf.html#a9f301088b6d4d8a07e5ac3dca8bfca19">Elf::loadModule</a>  (uint8_t *pBuffer, size_t length, uintptr_t &amp;loadBase, size_t &amp;loadSize, <a class="el" href="classSymbolTable.html">SymbolTable</a> *pSymbolTableCopy=0)</dt>
<dd><p class="startdd">Figure out how to map to the pages loaded by GRUB instead of copying into newly-allocated pages here. </p>
<p class="enddd">we should handle hidden symbols better so they are only needed for relocation and not tracked forever  </p>
</dd>
<dt><a class="anchor" id="_todo000515"></a>Member <a class="el" href="classElf.html#aacc40a0dbb05cf60cadd4a3ce6f187de">Elf::lookupSymbol</a>  (uintptr_t addr, uintptr_t *startAddr, T *symbolTable)</dt>
<dd>we should check for STV_HIDDEN symbol - but can't tell if we're local or not here and if we're local, a hidden symbol is totally fine. Need to indicate which ELF the relocation is for.  </dd>
<dt><a class="anchor" id="_todo000516"></a>Member <a class="el" href="classElf.html#a2f6b07c31f79f025df893df1a690e263">Elf::populateSymbolTable</a>  (<a class="el" href="classSymbolTable.html">SymbolTable</a> *pSymtab, uintptr_t loadBase)</dt>
<dd>Don't rely on this. Look at nchain in the hash table.  </dd>
<dt><a class="anchor" id="_todo000283"></a>Member <a class="el" href="classExt2Directory.html#a5b7ecbd5ee2645c044f465037da6f25a">Ext2Directory::addEntry</a>  (<a class="el" href="classString.html">String</a> filename, <a class="el" href="classFile.html">File</a> *pFile, size_t type)</dt>
<dd><p class="startdd">Ensure 4-byte alignment. </p>
<p>Previous directory entry might need its reclen updated to point to this new entry (as directory entries cannot cross block boundaries). </p>
<p class="enddd">Update our i_size for our directory.  </p>
</dd>
<dt><a class="anchor" id="_todo000287"></a>Member <a class="el" href="classExt2Directory.html#a077f08fd2241930e541d98035a1e108c">Ext2Directory::cacheDirectoryContents</a>  ()</dt>
<dd>need to handle short/failed reads better  </dd>
<dt><a class="anchor" id="_todo000286"></a>Member <a class="el" href="classExt2Directory.html#a2fdfeb17dba27bef1d3108f81f0eb21a">Ext2Directory::removeEntry</a>  (const <a class="el" href="classString.html">String</a> &amp;filename, <a class="el" href="classExt2Node.html">Ext2Node</a> *pFile)</dt>
<dd>Okay, this is not quite enough. The previous entry needs to be updated to skip past this now-empty entry. If this was the first entry, a blank record must be created to point to either the next entry or the end of the block.  </dd>
<dt><a class="anchor" id="_todo000292"></a>Member <a class="el" href="classExt2Filesystem.html#a01ee85a4315570e134649db8862790c9">Ext2Filesystem::createNode</a>  (<a class="el" href="classFile.html">File</a> *parent, const <a class="el" href="classString.html">String</a> &amp;filename, uint32_t mask, const <a class="el" href="classString.html">String</a> &amp;value, size_t type, uint32_t inodeOverride=0)</dt>
<dd><p class="startdd">Endianness! </p>
<p class="enddd">save group descriptor block number elsewhere  </p>
</dd>
<dt><a class="anchor" id="_todo000295"></a>Member <a class="el" href="classExt2Filesystem.html#a130e67a90b55ffa7b9fb683f647422a7">Ext2Filesystem::findFreeBlocks</a>  (uint32_t inode, size_t count, <a class="el" href="classVector.html">Vector&lt; uint32_t &gt;</a> &amp;blocks)</dt>
<dd>should release blocks if we failed to allocate enough blocks.  </dd>
<dt><a class="anchor" id="_todo000296"></a>Member <a class="el" href="classExt2Filesystem.html#a95939f01a564eb6e6871981dcecaf850">Ext2Filesystem::findFreeBlocksInGroup</a>  (uint32_t group, size_t maxCount, <a class="el" href="classVector.html">Vector&lt; uint32_t &gt;</a> &amp;blocks)</dt>
<dd><p class="startdd">Endianness - to ensure correct operation, must ptr be little endian? </p>
<p class="enddd">save group descriptor block number elsewhere  </p>
</dd>
<dt><a class="anchor" id="_todo000298"></a>Member <a class="el" href="classExt2Filesystem.html#a04b18a800fb490ba4e94410a960a2be1">Ext2Filesystem::findFreeInode</a>  ()</dt>
<dd><p class="startdd">Endianness - to ensure correct operation, must ptr be little endian? </p>
<p class="enddd">save group descriptor block number elsewhere  </p>
</dd>
<dt><a class="anchor" id="_todo000289"></a>Member <a class="el" href="classExt2Filesystem.html#a33f87a42cc16602e7d1ae0e7758e2295">Ext2Filesystem::initialise</a>  (<a class="el" href="classDisk.html">Disk</a> *pDisk)</dt>
<dd><p class="startdd">Check for journal required features. </p>
<p>Check all read-only features. </p>
<p class="enddd">Set g_pSparseBlock as read-only.  </p>
</dd>
<dt><a class="anchor" id="_todo000300"></a>Member <a class="el" href="classExt2Filesystem.html#aff9cf0bb1fded307d65e5d058f0a824d">Ext2Filesystem::releaseBlock</a>  (uint32_t block)</dt>
<dd>save group descriptor block number elsewhere  </dd>
<dt><a class="anchor" id="_todo000301"></a>Member <a class="el" href="classExt2Filesystem.html#af98f6f4d271fbc4ba16f4d24c154a309">Ext2Filesystem::releaseInode</a>  (uint32_t inode)</dt>
<dd>save group descriptor block number elsewhere  </dd>
<dt><a class="anchor" id="_todo000294"></a>Member <a class="el" href="classExt2Filesystem.html#aa0c8963217042f4391c321976048db60">Ext2Filesystem::remove</a>  (<a class="el" href="classFile.html">File</a> *parent, <a class="el" href="classFile.html">File</a> *file)</dt>
<dd>save group descriptor block number elsewhere  </dd>
<dt><a class="anchor" id="_todo000302"></a>Member <a class="el" href="classExt2Node.html#a7408e80b9ef789d60b3c7ede8174e938">Ext2Node::fileAttributeChanged</a>  (size_t size, size_t atime, size_t mtime, size_t ctime)</dt>
<dd>4GB files.  </dd>
<dt><a class="anchor" id="_todo000305"></a>Member <a class="el" href="classFatDirectory.html#afb7cb216b03b7bdff0b7da5db5594734">FatDirectory::addEntry</a>  (<a class="el" href="classString.html">String</a> filename, <a class="el" href="classFile.html">File</a> *pFile, size_t type)</dt>
<dd><p class="startdd">Some (sets of) entries will need to cross a cluster boundary </p>
<p class="enddd">Fill in other fields (eg, timestamps)  </p>
</dd>
<dt><a class="anchor" id="_todo000308"></a>Member <a class="el" href="classFatDirectory.html#a3c97dc214fe16d9509c5f85ad5e59753">FatDirectory::cacheDirectoryContents</a>  ()</dt>
<dd><a class="el" href="classString.html#af0699f9c73618777de005871e06b275e">String::chomp</a> should take an N parameter (default 1)  </dd>
<dt><a class="anchor" id="_todo000303"></a>Member <a class="el" href="classFatDirectory.html#a5036adf5e5ecef1b7f7c523955d67f44">FatDirectory::FatDirectory</a>  (<a class="el" href="classString.html">String</a> name, uintptr_t cluster, class <a class="el" href="classFatFilesystem.html">FatFilesystem</a> *pFs, <a class="el" href="classFile.html">File</a> *pParent, <a class="el" href="structFatFileInfo.html">FatFileInfo</a> &amp;info, uint32_t dirClus=0, uint32_t dirOffset=0)</dt>
<dd><p class="startdd">Permissions </p>
<p class="enddd">Ownership of files  </p>
</dd>
<dt><a class="anchor" id="_todo000307"></a>Member <a class="el" href="classFatDirectory.html#aeaf762ccdf8b2ded950a7fd4f68aba2f">FatDirectory::removeEntry</a>  (<a class="el" href="classFile.html">File</a> *pFile)</dt>
<dd>Save the previous cluster in <a class="el" href="classFatFile.html">FatFile</a> too  </dd>
<dt><a class="anchor" id="_todo000312"></a>Member <a class="el" href="classFatFilesystem.html#ad185c8e66258645bab3ec794b2b20f6d">FatFilesystem::convertFilenameTo</a>  (<a class="el" href="classString.html">String</a> filename) const </dt>
<dd>This should increment if a file is found with the same name!  </dd>
<dt><a class="anchor" id="_todo000309"></a>Member <a class="el" href="classFatFilesystem.html#a7ab7d558a44fe416c70721c9be1a04a8">FatFilesystem::findFreeCluster</a>  (bool bLock=false)</dt>
<dd>For FAT32, update the FSInfo structure  </dd>
<dt><a class="anchor" id="_todo000310"></a>Member <a class="el" href="classFatFilesystem.html#a8928635b8e4aca73a53db496342cbd1c">FatFilesystem::getClusterEntry</a>  (uint32_t cluster, bool bLock=true)</dt>
<dd></dd>
<dt><a class="anchor" id="_todo000313"></a>Member <a class="el" href="classFatFilesystem.html#a06c54728e4f5b4c62efc87ede624e3c8">FatFilesystem::getFatDate</a>  (Time::Timestamp timestamp) const </dt>
<dd>Write  </dd>
<dt><a class="anchor" id="_todo000311"></a>Member <a class="el" href="classFatFilesystem.html#a99b6a766fc679c654e9ca1b62230ef0c">FatFilesystem::setClusterEntry</a>  (uint32_t cluster, uint32_t value, bool bLock=true)</dt>
<dd></dd>
<dt><a class="anchor" id="_todo000372"></a>Member <a class="el" href="classFile.html#a29f9b0b8ee6a02ef8c5deb2b516fc022">File::read</a>  (uint64_t location, uint64_t size, uintptr_t buffer, bool bCanBlock=true) final</dt>
<dd>consider caching this still  </dd>
<dt><a class="anchor" id="_todo000374"></a>Member <a class="el" href="classFile.html#a8be3584ef2f2a607cee6ed7f36784876">File::readIntoCache</a>  (uintptr_t block)</dt>
<dd>handle readBlock failing here  </dd>
<dt><a class="anchor" id="_todo000373"></a>Member <a class="el" href="classFile.html#a4fb6cc9ecdd0abf699a3115069e868d5">File::write</a>  (uint64_t location, uint64_t size, uintptr_t buffer, bool bCanBlock=true) final</dt>
<dd>consider caching this still  </dd>
<dt><a class="anchor" id="_todo000371"></a>Member <a class="el" href="classFile.html#aafb02d941efbaa4239f7d8e820716604">File::writeCallback</a>  (CacheConstants::CallbackCause cause, uintptr_t loc, uintptr_t page, void *meta)</dt>
<dd>handle block size &lt; 4K??  </dd>
<dt><a class="anchor" id="_todo000145"></a>Member <a class="el" href="classFileDescriptor.html#a176217ba0c5946dc21ab910a1714ea02">FileDescriptor::fdflags</a>  </dt>
<dd>swap this to private and fix everything that breaks  </dd>
<dt><a class="anchor" id="_todo000143"></a>Member <a class="el" href="classFileDescriptor.html#ad50dcfb3e3da1f73e6b042cefdb7415a">FileDescriptor::FileDescriptor</a>  (<a class="el" href="classFile.html">File</a> *newFile, uint64_t newOffset=0, size_t newFd=0xFFFFFFFF, int fdFlags=0, int flFlags=0, <a class="el" href="classLockedFile.html">LockedFile</a> *lf=0)</dt>
<dd>need a copy constructor for networkImpl  </dd>
<dt><a class="anchor" id="_todo000144"></a>Member <a class="el" href="classFileDescriptor.html#aa35c2eba5a0e8771661a61619d234560">FileDescriptor::setStatusFlags</a>  (int newFlags)</dt>
<dd>this blocks <em>all</em> operations on the socket. However, we should only be blocking operations associated with <em>this descriptor</em> on the socket! maybe pass in a <a class="el" href="classFileDescriptor.html">FileDescriptor</a> to recvfrom et al?  </dd>
<dt><a class="anchor" id="_todo000329"></a>Member <a class="el" href="classFileDisk.html#a02061aaa21996366d8056ce0b2c14d52">FileDisk::cacheIsCritical</a>  ()</dt>
<dd>Could it be possible to allow writes to go through to the file we've mounted? Then this could return true if the backing device is read-only, false otherwise.  </dd>
<dt><a class="anchor" id="_todo000327"></a>Member <a class="el" href="classFileDisk.html#a9fb5d6f8bf1f975c8a8ee90bee96e59e">FileDisk::write</a>  (uint64_t location)</dt>
<dd>implement this  </dd>
<dt><a class="anchor" id="_todo000375"></a>Member <a class="el" href="classFilesystem.html#ac9060f083c3fc3cb973d1ac83a7abe15">Filesystem::findNode</a>  (<a class="el" href="classFile.html">File</a> *pNode, <a class="el" href="classStringView.html">StringView</a> path)</dt>
<dd>do we need to do permissions checks at each intermediate step?  </dd>
<dt><a class="anchor" id="_todo000589"></a>Member <a class="el" href="classFont.html#abaef3d8a2f91905b6bab4ceea4f4cafd">Font::Font</a>  (cairo_t *pCairo, size_t requestedSize, const char *pFilename, bool bCache, size_t nWidth)</dt>
<dd>UTF-32 endianness  </dd>
<dt><a class="anchor" id="_todo000590"></a>Member <a class="el" href="classFont.html#a628b8416e81db3ffed06187a00635be2">Font::render</a>  (const char *s, size_t x, size_t y, uint32_t f, uint32_t b, bool bBack=true, bool bBold=false, bool bItalic=false, bool bUnderline=false)</dt>
<dd>cleanup  </dd>
<dt><a class="anchor" id="_todo000529"></a>Member <a class="el" href="classFramebuffer.html#adc413e94f48067bc51adf2cb9151844b">Framebuffer::redraw</a>  (size_t x=~0UL, size_t y=~0UL, size_t w=~0UL, size_t h=~0UL, bool bChild=false)</dt>
<dd>nChildren parameter - this is not necessary if no children!  </dd>
<dt><a class="anchor" id="_todo000531"></a>Member <a class="el" href="classFramebuffer.html#ac6114c5a53f666a29fa54712eb91e3d6">Framebuffer::swBlit</a>  (<a class="el" href="structGraphics_1_1Buffer.html">Graphics::Buffer</a> *pBuffer, size_t srcx, size_t srcy, size_t destx, size_t desty, size_t width, size_t height)</dt>
<dd>This code is broken for the case where srcx/srcy are not zero. :(  </dd>
<dt><a class="anchor" id="_todo000534"></a>Member <a class="el" href="classFramebuffer.html#a84f1fa7d95284d10f80182650afd0657">Framebuffer::swCopy</a>  (size_t srcx, size_t srcy, size_t destx, size_t desty, size_t w, size_t h)</dt>
<dd>consider source bytes per line?  </dd>
<dt><a class="anchor" id="_todo000530"></a>Member <a class="el" href="classFramebuffer.html#a6a7fda43d9b792b66d56818b9888d023">Framebuffer::swCreateBuffer</a>  (const void *srcData, Graphics::PixelFormat srcFormat, size_t width, size_t height, uint32_t *pPalette)</dt>
<dd>8-bit  </dd>
<dt><a class="anchor" id="_todo000532"></a>Member <a class="el" href="classFramebuffer.html#a526db723702418732e83af3b75575c32">Framebuffer::swRect</a>  (size_t x, size_t y, size_t width, size_t height, uint32_t colour, Graphics::PixelFormat format)</dt>
<dd><p class="startdd">Handle 24-bit properly </p>
<p class="enddd">Handle 24-bit properly  </p>
</dd>
<dt><a class="anchor" id="_todo000535"></a>Member <a class="el" href="classFramebuffer.html#a13e8473c39cffde57d7ba7c249697ba2">Framebuffer::swSetPixel</a>  (size_t x, size_t y, uint32_t colour, Graphics::PixelFormat format=Graphics::Bits32_Argb)</dt>
<dd>8-bit  </dd>
<dt><a class="anchor" id="_todo000107"></a>Member <a class="el" href="classFramebufferFile.html#a6394c053b50f045b8f8c4cff7d6c26ed">FramebufferFile::command</a>  (const size_t command, void *buffer)</dt>
<dd><p class="startdd">What if there is no text mode!? </p>
<p>Magic number. </p>
<p class="enddd">What if there is no text mode!?  </p>
</dd>
<dt><a class="anchor" id="_todo000110"></a>Member <a class="el" href="classFramebufferFile.html#a04909ec62f7a20ffa9a9499637125342">FramebufferFile::m_pGraphicsParameters</a>  </dt>
<dd>pinBlock/unpinBlock should pin/unpin physical pages!  </dd>
<dt><a class="anchor" id="_todo000106"></a>Member <a class="el" href="classFramebufferFile.html#af2b1e0735a540d03751a96df5aebea52">FramebufferFile::readBlock</a>  (uint64_t location)</dt>
<dd>If this is NOT virtual, we need to do something about that.  </dd>
<dt><a class="anchor" id="_todo000213"></a>Member <a class="el" href="group__kernelprocessorx86common.html#ga585ae6c88602d73a42dd8386c7f3508e">g_FreePages</a>  </dt>
<dd>expose this via <a class="el" href="classPhysicalMemoryManager.html">PhysicalMemoryManager</a> interface  </dd>
<dt><a class="anchor" id="_todo000509"></a>Member <a class="el" href="classGraphicsService.html#a8b4038c45e963da6ffe17b0fdf9a4bf0">GraphicsService::serve</a>  (<a class="el" href="classServiceFeatures.html#ac80f681c1462fb3606b644e3297c5cab">ServiceFeatures::Type</a> type, void *pData, size_t dataLen)</dt>
<dd>Sanity check  </dd>
<dt><a class="anchor" id="_todo000466"></a>Member <a class="el" href="classHashedPageTable.html#a9c419540a1db54429db9bf13d5e91328">HashedPageTable::addMapping</a>  (uint32_t effectiveAddress, uint32_t physicalAddress, uint32_t mode, uint32_t vsid)</dt>
<dd>change this to random replacement.  </dd>
<dt><a class="anchor" id="_todo000465"></a>Member <a class="el" href="classHashedPageTable.html#a20d472881b91f0c51371c9fd4f606d65">HashedPageTable::initialise</a>  (<a class="el" href="classTranslations.html">Translations</a> &amp;translations, uint32_t ramMax)</dt>
<dd>Get rid of this hardcoded 0x200000.  </dd>
<dt><a class="anchor" id="_todo000403"></a>Class <a class="el" href="classHashTable.html">HashTable&lt; K, V, SiblingK, InitialBuckets, QuadraticProbe, GrowthFactor &gt;</a>  </dt>
<dd>check InitialBuckets for is a power of two  </dd>
<dt><a class="anchor" id="_todo000039"></a>Member <a class="el" href="structHidReport_1_1InputBlock.html#a51f3e1ba798499107d0e3858746ceac6">HidReport::InputBlock::feedInput</a>  (uint8_t *pBuffer, uint8_t *pOldBuffer, size_t nBufferSize, size_t &amp;nBitOffset, HidDeviceType deviceType)</dt>
<dd>Do implement support  </dd>
<dt><a class="anchor" id="_todo000040"></a>Member <a class="el" href="namespaceHidUtils.html#a61723805418c7b34c156f9f6f78e30a5">HidUtils::sendInputToManager</a>  (HidDeviceType deviceType, uint16_t nUsagePage, uint16_t nUsage, int64_t nRelativeValue)</dt>
<dd>Matt, fix the damn input manager!!!  </dd>
<dt><a class="anchor" id="_todo000459"></a>Member <a class="el" href="classHostedInterruptManager.html#a08f5c431954d98c6969c16ffd71d26a9">HostedInterruptManager::interrupt</a>  (InterruptState &amp;interruptState)</dt>
<dd>Provide a better entry point for system shutdown.  </dd>
<dt><a class="anchor" id="_todo000460"></a>Member <a class="el" href="classHostedPhysicalMemoryManager.html#a2e7357b1554b331b35460ee9491b9d96">HostedPhysicalMemoryManager::m_MemoryRegions</a>  </dt>
<dd>rename this member (conflicts with <a class="el" href="classPhysicalMemoryManager.html#adcab0a2f52ba2ec74476a04515c8ba8e">PhysicalMemoryManager::m_MemoryRegions</a>)  </dd>
<dt><a class="anchor" id="_todo000536"></a>Member <a class="el" href="classHostedSchedulerTimer.html#a49e8e1b2a7f2127c45e17a2183ca5088">HostedSchedulerTimer::initialise</a>  () INITIALISATION_ONLY</dt>
<dd>error message or something  </dd>
<dt><a class="anchor" id="_todo000537"></a>Member <a class="el" href="classHostedTimer.html#aee87a1470a9f9115ce20726f06da6bad">HostedTimer::initialise</a>  () INITIALISATION_ONLY</dt>
<dd>error message or something  </dd>
<dt><a class="anchor" id="_todo000538"></a>Member <a class="el" href="classInputManager.html#adfff346563bcb1ffc32f36365d43a3aa">InputManager::mainThread</a>  ()</dt>
<dd><p class="startdd">Handle exit condition </p>
<p class="enddd">Verify that the callback is in fact in the kernel  </p>
</dd>
<dt><a class="anchor" id="_todo000196"></a>Member <a class="el" href="classIntervalTimer.html#a5a21987eed6d4003dfecc1e1350ea5f8">IntervalTimer::signal</a>  ()</dt>
<dd>sanity check that this is absolutely a <a class="el" href="classPosixSubsystem.html">PosixSubsystem</a>  </dd>
<dt><a class="anchor" id="_todo000420"></a>Member <a class="el" href="classIpc_1_1IpcMessage.html#acb96401c47a148e747376d7327c0317d">Ipc::IpcMessage::~IpcMessage</a>  ()</dt>
<dd>Problem: an endpoint might still have this message in a queue. We should notify it that we're now dead.  </dd>
<dt><a class="anchor" id="_todo000315"></a>Member <a class="el" href="classIso9660Filesystem.html#a7dad71e5ee25e68e238d9be64b122082">Iso9660Filesystem::initialise</a>  (<a class="el" href="classDisk.html">Disk</a> *pDisk)</dt>
<dd>Obtain disk information (perhaps a new call in <a class="el" href="classDisk.html">Disk</a>?)  </dd>
<dt><a class="anchor" id="_todo000517"></a>Member <a class="el" href="classKernelElf.html#ad0db2ea17f26dafb0b29b2718d7ec4c2">KernelElf::globalLookupSymbol</a>  (uintptr_t addr, uintptr_t *startAddr=0)</dt>
<dd>This shouldn't match local or weak symbols.  </dd>
<dt><a class="anchor" id="_todo000376"></a>Member <a class="el" href="classLockedFile.html#ae8a5548c309a61bc7c6131a74abd46c7">LockedFile::operator=</a>  (const <a class="el" href="classLockedFile.html">LockedFile</a> &amp;c)</dt>
<dd>Write me!  </dd>
<dt><a class="anchor" id="_todo000503"></a>Member <a class="el" href="classLocksCommand.html#ac6858335662f9e6d0bc536313ac9f212">LocksCommand::lockReleased</a>  (const <a class="el" href="classSpinlock.html">Spinlock</a> *pLock, size_t nCpu=~0U)</dt>
<dd>not SMP-safe...  </dd>
<dt><a class="anchor" id="_todo000518"></a>Member <a class="el" href="classLog.html#a30011be927b825cbe4a98aa0b2100712">Log::installCallback</a>  (<a class="el" href="classLog_1_1LogCallback.html">LogCallback</a> *pCallback, bool bSkipBacklog=false)</dt>
<dd>installCallback should return success/failure  </dd>
<dt><a class="anchor" id="_todo000337"></a>Member <a class="el" href="group__lwip__opts__netif.html#gabafb9f64a80e51b56c0abbcfc1f7e04e">LWIP_NETIF_TX_SINGLE_PBUF</a>  </dt>
<dd>: TCP and IP-frag do not work with this, yet:  </dd>
<dt><a class="anchor" id="_todo000171"></a>Member <a class="el" href="classLwipSocketSyscalls.html#a472b532e517b632dcebcb69fe9eda825">LwipSocketSyscalls::accept</a>  (struct sockaddr *address, socklen_t *addrlen)</dt>
<dd>handle other families  </dd>
<dt><a class="anchor" id="_todo000166"></a>Member <a class="el" href="classLwipSocketSyscalls.html#abaec47409de129cb4a2589b093f7a295">LwipSocketSyscalls::connect</a>  (const struct sockaddr *address, socklen_t addrlen)</dt>
<dd><p class="startdd">need to track if we've already done a bind() and not bind if so </p>
<p class="enddd">for <a class="el" href="classLwipSocketSyscalls.html#a472b532e517b632dcebcb69fe9eda825">accept()</a> we need to do this too  </p>
</dd>
<dt><a class="anchor" id="_todo000165"></a>Member <a class="el" href="classLwipSocketSyscalls.html#aeb33d7135f68741960c6eed770a6987b">LwipSocketSyscalls::create</a>  ()</dt>
<dd>need an error here...  </dd>
<dt><a class="anchor" id="_todo000172"></a>Member <a class="el" href="classLwipSocketSyscalls.html#a5774a21850b99307e969641cc3737724">LwipSocketSyscalls::getpeername</a>  (struct sockaddr *address, socklen_t *address_len)</dt>
<dd>handle other families  </dd>
<dt><a class="anchor" id="_todo000173"></a>Member <a class="el" href="classLwipSocketSyscalls.html#ae5fb359bb4dd1ff42754f389d14ad6db">LwipSocketSyscalls::getsockname</a>  (struct sockaddr *address, socklen_t *address_len)</dt>
<dd>handle other families  </dd>
<dt><a class="anchor" id="_todo000175"></a>Member <a class="el" href="classLwipSocketSyscalls.html#a8f3948089f3c6ab11ec0018627196b1e">LwipSocketSyscalls::getsockopt</a>  (int level, int optname, void *optvalue, socklen_t *optlen)</dt>
<dd>implement with lwIP functionality  </dd>
<dt><a class="anchor" id="_todo000177"></a>Member <a class="el" href="classLwipSocketSyscalls.html#a0853b04eb073ce2663e6a392c0e22f1d">LwipSocketSyscalls::netconnCallback</a>  (struct netconn *conn, enum netconn_evt evt, uint16_t len)</dt>
<dd><p class="startdd">figure out how to bubble errors </p>
<p class="enddd">need a way to do this with lwip when threads are off  </p>
</dd>
<dt><a class="anchor" id="_todo000176"></a>Member <a class="el" href="classLwipSocketSyscalls.html#adb3cacab79293ff74bd2a115992ac08a">LwipSocketSyscalls::poll</a>  (bool &amp;read, bool &amp;write, bool &amp;error, <a class="el" href="classSemaphore.html">Semaphore</a> *waiter)</dt>
<dd>this is buggy as it'll return for the wrong events!  </dd>
<dt><a class="anchor" id="_todo000170"></a>Member <a class="el" href="classLwipSocketSyscalls.html#acdaa7809c465a4ac9694426f2092d68f">LwipSocketSyscalls::recvfrom_msg</a>  (struct msghdr *msghdr)</dt>
<dd>need to build this - extract from the pbuf  </dd>
<dt><a class="anchor" id="_todo000168"></a>Member <a class="el" href="classLwipSocketSyscalls.html#a0faed1590f537f2f8138f0bb3faafa05">LwipSocketSyscalls::sendto_msg</a>  (const struct msghdr *msghdr)</dt>
<dd><p class="startdd">need to build this - but netconn_sendto() requires a netbuf </p>
<p class="enddd">implement sendto  </p>
</dd>
<dt><a class="anchor" id="_todo000174"></a>Member <a class="el" href="classLwipSocketSyscalls.html#a75e72bc88702a881dbdc55f4731e5da5">LwipSocketSyscalls::setsockopt</a>  (int level, int optname, const void *optvalue, socklen_t optlen)</dt>
<dd>implement with lwIP functionality  </dd>
<dt><a class="anchor" id="_todo000504"></a>Member <a class="el" href="classMappingCommand.html#a55b4a6f9d3cfafacaec4a97bdb3276e5">MappingCommand::execute</a>  (const HugeStaticString &amp;input, HugeStaticString &amp;output, InterruptState &amp;state, <a class="el" href="classDebuggerIO.html">DebuggerIO</a> *screen)</dt>
<dd>define operator != on <a class="el" href="classStaticString.html">StaticString</a>  </dd>
<dt><a class="anchor" id="_todo000379"></a>Member <a class="el" href="classMemoryMapManager.html#a5c4bd2a967dcc874e8ca71c921ec40d9">MemoryMapManager::sanitiseAddress</a>  (uintptr_t &amp;address, size_t length)</dt>
<dd><p class="startdd">rework APIs a lot. </p>
<p class="enddd">allocateSpecific in the dynamic space allocator if address is within that range.  </p>
</dd>
<dt><a class="anchor" id="_todo000381"></a><a class="el" href="classFile.html">File</a> <a class="el" href="MemoryMappedFile_8h.html">MemoryMappedFile.h</a>  </dt>
<dd>Handle writing of files, not just reading.  </dd>
<dt><a class="anchor" id="_todo000382"></a>Member <a class="el" href="classMemoryMappedFile.html#a15a438cb79df2de64157cab4cbacc25e">MemoryMappedFile::compact</a>  ()</dt>
<dd>Improve this. </dd>
<dt><a class="anchor" id="_todo000378"></a>Member <a class="el" href="classMemoryMappedFile.html#ab81975953742d8551460d4fa59a38e3a">MemoryMappedFile::trap</a>  (uintptr_t address, bool bWrite)</dt>
<dd>how to manage this with potentially more traps taking place?  </dd>
<dt><a class="anchor" id="_todo000558"></a>Member <a class="el" href="classMemoryPool.html#ae7c3c0072eb2917ba1d31793c1918c3f">MemoryPool::allocateDoer</a>  (bool canBlock)</dt>
<dd>better error handling  </dd>
<dt><a class="anchor" id="_todo000461"></a>Member <a class="el" href="classMIPS32InterruptManager.html#a40a4f21b5138166dc1adbb3005956650">MIPS32InterruptManager::initialiseProcessor</a>  ()</dt>
<dd>and some smp/acpi function  </dd>
<dt><a class="anchor" id="_todo000462"></a>Member <a class="el" href="classMIPS32VirtualAddressSpace.html#a38b0f79f6eb04c2b526dbc9ea1da5008">MIPS32VirtualAddressSpace::map</a>  (physical_uintptr_t physicalAddress, void *virtualAddress, size_t flags)</dt>
<dd>When is an entry global? In KSEG2? But the page table TLB entries are ASID specific... hmm.  </dd>
<dt><a class="anchor" id="_todo000075"></a>Page <a class="el" href="module_nativeapi.html">Native API</a>  </dt>
<dd>Write a new configuration system API using the new native API scheme.  </dd>
<dt><a class="anchor" id="_todo000076"></a>Member <a class="el" href="classNativeBase.html#a6b571f2fa79fb20cf32ae92f08417e4c">NativeBase::syscall</a>  (uint64_t subid, void *params, size_t params_size)=0</dt>
<dd>this definition needs work  </dd>
<dt><a class="anchor" id="_todo000077"></a>Member <a class="el" href="classNativeSyscallManager.html#a21ed29f54e0d835f7f55db75861ed39e">NativeSyscallManager::syscall</a>  (SyscallState &amp;state)</dt>
<dd>check that pointer parameters are mapped.  </dd>
<dt><a class="anchor" id="_todo000060"></a>Member <a class="el" href="classNe2k.html#a9f3b84c8016fd90e7b13b447edb82f0e">Ne2k::irq</a>  (irq_id_t number, InterruptState &amp;state)</dt>
<dd>Handle properly  </dd>
<dt><a class="anchor" id="_todo000059"></a>Member <a class="el" href="classNe2k.html#a7a21a7e54926ef73242b3706ecfe251d">Ne2k::Ne2k</a>  (<a class="el" href="classNetwork.html">Network</a> *pDev)</dt>
<dd>Proper multicast subscription via the <a class="el" href="classNetwork.html">Network</a> card abstraction  </dd>
<dt><a class="anchor" id="_todo000344"></a>Member <a class="el" href="classNetworkFilter.html#a9673bc9df57eacc3cd7de8c9092a9f13">NetworkFilter::filter</a>  (size_t level, uintptr_t packet, size_t sz)</dt>
<dd>Callbacks should be able to return a code which requests a specific response, such as ICMP Unreachable or something, rather than just dropping the packet.  </dd>
<dt><a class="anchor" id="_todo000342"></a>Member <a class="el" href="classNetworkFilter.html#a079011edc806924856a2533bc507c5b9">NetworkFilter::installCallback</a>  (size_t level, bool(*callback)(uintptr_t, size_t))</dt>
<dd><a class="el" href="classUnlikelyLock.html">UnlikelyLock</a> here  </dd>
<dt><a class="anchor" id="_todo000343"></a>Member <a class="el" href="classNetworkFilter.html#ac1d1b88741d365355ef6d116b9c83ab9">NetworkFilter::removeCallback</a>  (size_t level, size_t id)</dt>
<dd>Implement me!  </dd>
<dt><a class="anchor" id="_todo000404"></a>Class <a class="el" href="classObjectPool.html">ObjectPool&lt; T, poolSize &gt;</a>  </dt>
<dd>add a <a class="el" href="classMemoryPressureHandler.html">MemoryPressureHandler</a> here.  </dd>
<dt><a class="anchor" id="_todo000546"></a>Member <a class="el" href="classOFDevice.html#a9192702fee1e438b0096783f5fb099be">OFDevice::setProperty</a>  (const char *pProperty, NormalStaticString &amp;val)</dt>
<dd></dd>
<dt><a class="anchor" id="_todo000051"></a>Member <a class="el" href="classOhci.html#a03571155388515d314d07e9473b6d2ec">Ohci::addTransferToTransaction</a>  (uintptr_t pTransaction, bool bToggle, UsbPid pid, uintptr_t pBuffer, size_t nBytes)</dt>
<dd>Clean up!  </dd>
<dt><a class="anchor" id="_todo000050"></a>Member <a class="el" href="classOhci.html#a2ddb51d83c6a046620eecb33c5a14e74">Ohci::irq</a>  (irq_id_t number, InterruptState &amp;state)</dt>
<dd>Handle.  </dd>
<dt><a class="anchor" id="_todo000052"></a>Member <a class="el" href="classOhci.html#a2328c3f389b05d140b976d71cd838414">Ohci::portReset</a>  (uint8_t nPort, bool bErrorResponse=false)</dt>
<dd>Error handling? <a class="el" href="classDevice.html">Device</a> fails to reset? Not present after reset?  </dd>
<dt><a class="anchor" id="_todo000053"></a>Member <a class="el" href="classOhci.html#ae64a72ae2e53a0afd1ab90c87e21d31d">Ohci::ptv_ed</a>  (physical_uintptr_t phys)</dt>
<dd>defines for the list sizes so changing one doesn't involve rewriting heaps of code  </dd>
<dt><a class="anchor" id="_todo000049"></a>Member <a class="el" href="classOhci.html#a844e1d21343ac4ac6f09539f36952493">Ohci::removeED</a>  (<a class="el" href="structOhci_1_1ED.html">ED</a> *pED)</dt>
<dd>Isochronous and Periodic.  </dd>
<dt><a class="anchor" id="_todo000547"></a>Member <a class="el" href="classOpenPic.html#a68820f005a26307d4227f962bf5e8ac4">OpenPic::initialise</a>  () INITIALISATION_ONLY</dt>
<dd>Set up timers.  </dd>
<dt><a class="anchor" id="_todo000479"></a>Member <a class="el" href="classPageFaultHandler.html#ac634b3b9f72934a18460566d355bea92">PageFaultHandler::interrupt</a>  (size_t interruptNumber, InterruptState &amp;state)</dt>
<dd>probably can just skip checking for traps across the entire kernel address space?  </dd>
<dt><a class="anchor" id="_todo000446"></a>Member <a class="el" href="classPageFaultHandler.html#a515d9f3d82ab3b269ef62aba847e11c9">PageFaultHandler::m_Instance</a>  </dt>
<dd>Implement  </dd>
<dt><a class="anchor" id="_todo000022"></a>Member <a class="el" href="classPciAtaController.html#a4ecebbc1ccbe372364d5931c892229d2">PciAtaController::PciAtaController</a>  (<a class="el" href="classController.html">Controller</a> *pDev, int nController=0)</dt>
<dd><p class="startdd">for ICH and the like, there's more Ultra DMA configuration. </p>
<p><a class="el" href="classBus.html">Bus</a> master registerss may be memory mapped... </p>
<p>ICH will have "native mode" to worry about </p>
<p class="enddd">Detect PCI IRQ, don't use ISA IRQs in native mode (etc...)  </p>
</dd>
<dt><a class="anchor" id="_todo000214"></a>Member <a class="el" href="classPciDevicesFile.html#a8ef924c6975a2e7937453acce58520db">PciDevicesFile::resync</a>  ()</dt>
<dd><p class="startdd">need to add some flags here </p>
<p class="enddd">add driver name here if known?  </p>
</dd>
<dt><a class="anchor" id="_todo000572"></a>Member <a class="el" href="classPedigree_1_1IpAddress.html#a1bf31978826232bf57aa177d0e93d857">Pedigree::IpAddress::toString</a>  ()</dt>
<dd>IPv6  </dd>
<dt><a class="anchor" id="_todo000573"></a>Member <a class="el" href="classPedigree_1_1NetworkDevice.html#a1de106caf5586886dea1687fb7c60f27">Pedigree::NetworkDevice::subnet</a>  </dt>
<dd><a class="el" href="classStationInfo.html">StationInfo</a> in Pedigree  </dd>
<dt><a class="anchor" id="_todo000071"></a>Member <a class="el" href="structPedigreeGraphics_1_1GraphicsProvider.html#ac8a5318f6398c932ba3c44a4c0eef0b7">PedigreeGraphics::GraphicsProvider::pDisplay</a>  </dt>
<dd>Provide the current graphics mode via a watered-down <a class="el" href="classDisplay.html">Display</a> class.  </dd>
<dt><a class="anchor" id="_todo000422"></a>Member <a class="el" href="classPerProcessorScheduler.html#a89f2b84d3179c6dc2a9169ad0706355b">PerProcessorScheduler::checkEventState</a>  (uintptr_t userStack)</dt>
<dd>This is a quickfix for a bigger problem. I imagine it has something to do with calling execve directly without fork, meaning the memory is cleaned up but the state level stack information is <em>not</em>.  </dd>
<dt><a class="anchor" id="_todo000421"></a>Member <a class="el" href="classPerProcessorScheduler.html#ad75ba94db5d0e4ff311fc1577b662472">PerProcessorScheduler::processorAddThread</a>  (void *instance) NORETURN</dt>
<dd>handle result  </dd>
<dt><a class="anchor" id="_todo000578"></a>Member <a class="el" href="classPng.html#ae4c90123f85aad5feab68a9c466529b4">Png::Png</a>  (const char *filename)</dt>
<dd>clean up after these errors.  </dd>
<dt><a class="anchor" id="_todo000199"></a>Member <a class="el" href="classPosixSubsystem.html#ac2d6e4d427bc8c967ca42577f202c6ee">PosixSubsystem::addFileDescriptor</a>  (size_t fd, <a class="el" href="classFileDescriptor.html">FileDescriptor</a> *pFd)</dt>
<dd>this is possibly racy  </dd>
<dt><a class="anchor" id="_todo000210"></a>Class <a class="el" href="structPosixSubsystem_1_1AlternateSignalStack.html">PosixSubsystem::AlternateSignalStack</a>  </dt>
<dd>Figure out how to make this work for more than just the current process (ie, work with CheckEventState... Which requires exposing parts of the POSIX subsystem to the scheduler - not good!).  </dd>
<dt><a class="anchor" id="_todo000209"></a>Member <a class="el" href="classPosixSubsystem.html#aebeb7194a0d4fd8f83c444427648deb8">PosixSubsystem::checkAddress</a>  (uintptr_t addr, size_t extent, size_t flags)</dt>
<dd>This has a security flaw in that between the check and the use of the actual pointer, the pointer can become invalid due to other threads being active in the process. It may be worth having a Process-wide <a class="el" href="classUnlikelyLock.html">UnlikelyLock</a> which has the mmap family of functions, sbrk, etc... as writers, and all other syscalls as readers. This would ensure a multithreaded application is not able to crash the kernel.  </dd>
<dt><a class="anchor" id="_todo000211"></a>Member <a class="el" href="classPosixSubsystem.html#aadb5e7a8bef89ced4d429c83a927a27d">PosixSubsystem::insertThread</a>  (size_t n, <a class="el" href="classPosixSubsystem_1_1PosixThread.html">PosixThread</a> *thread)</dt>
<dd>It might be safe to delete the pointer... We'll see.  </dd>
<dt><a class="anchor" id="_todo000201"></a>Member <a class="el" href="classPosixSubsystem.html#a0f81eb461d078c36950283ce71a45e05">PosixSubsystem::invoke</a>  (<a class="el" href="classFile.html">File</a> *originalFile, const <a class="el" href="classString.html">String</a> &amp;originalName, Vector&lt; String &gt; &amp;argv, Vector&lt; String &gt; &amp;env, SyscallState *state)</dt>
<dd><p class="startdd">actually we are supposed to kill them all here </p>
<p>do we need to relocate at all? </p>
<p>cleanup </p>
<p>cleanup </p>
<p>should only do this for setuid/setgid programs </p>
<p>platform assumption here. </p>
<p class="enddd">16 random bytes, not 16 zero bytes  </p>
</dd>
<dt><a class="anchor" id="_todo000198"></a>Member <a class="el" href="classPosixSubsystem.html#aa8ee8389b87d74875f36e3de50108ae7">PosixSubsystem::kill</a>  (KillReason killReason, <a class="el" href="classThread.html">Thread</a> *pThread)</dt>
<dd>we probably want to avoid allocating a new stack..  </dd>
<dt><a class="anchor" id="_todo000200"></a>Member <a class="el" href="classPosixSubsystem.html#a5bbd21893924596a4ef7fcb134d94e33">PosixSubsystem::parseShebang</a>  (<a class="el" href="classFile.html">File</a> *pFile, <a class="el" href="classFile.html">File</a> *&amp;outFile, Vector&lt; String &gt; &amp;argv)</dt>
<dd>this loop could terminate MUCH faster  </dd>
<dt><a class="anchor" id="_todo000212"></a>Member <a class="el" href="classPosixSubsystem.html#ac770e1016dcddd2864bc519d3d21c1d9">PosixSubsystem::removeThread</a>  (size_t n)</dt>
<dd>It might be safe to delete the pointer... We'll see.  </dd>
<dt><a class="anchor" id="_todo000197"></a>Member <a class="el" href="classPosixSubsystem.html#a36cc1a08370b8c19e31e8d0b2adce3c5">PosixSubsystem::~PosixSubsystem</a>  ()</dt>
<dd>Call the destructor (need a way to call into userspace and return back here)  </dd>
<dt><a class="anchor" id="_todo000467"></a>Member <a class="el" href="classPPC32InterruptManager.html#a838686d5771d313f4a2febe5a5be75b1">PPC32InterruptManager::initialiseProcessor</a>  ()</dt>
<dd>and some smp/acpi function  </dd>
<dt><a class="anchor" id="_todo000471"></a>Member <a class="el" href="classPPC32VirtualAddressSpace.html#a7d60c6be12c1291d73f92ad2f75884c4">PPC32VirtualAddressSpace::clone</a>  ()</dt>
<dd>Copy on write.  </dd>
<dt><a class="anchor" id="_todo000469"></a>Member <a class="el" href="classPPC32VirtualAddressSpace.html#ae996153cbe09e1f3ce516084c45b331d">PPC32VirtualAddressSpace::initialise</a>  (<a class="el" href="classTranslations.html">Translations</a> &amp;translations)</dt>
<dd><p class="startdd">the 0x6a is temporary and wrong. Find a proper mode. (0x2 doesn't seem to work) </p>
<p class="enddd">Holy magic numbers, batman! the 0x100 is a bit hardcoded, isn't it?  </p>
</dd>
<dt><a class="anchor" id="_todo000472"></a>Member <a class="el" href="classPpcCommonPhysicalMemoryManager_1_1PageStack.html#a394d67a3d497716c8d4cd7388ef923f7">PpcCommonPhysicalMemoryManager::PageStack::allocate</a>  ()</dt>
<dd>Swapspace here.  </dd>
<dt><a class="anchor" id="_todo000548"></a>Member <a class="el" href="classPPCVga.html#a99248961cc4536d151e37c4a0acf9b80">PPCVga::initialise</a>  ()</dt>
<dd>Something with <a class="el" href="classVirtualAddressSpace.html">VirtualAddressSpace</a> here?  </dd>
<dt><a class="anchor" id="_todo000549"></a>Member <a class="el" href="classPPCVga.html#a66ea83bc76b54e05cb58507fc636b09f">PPCVga::m_pFramebuffer</a>  </dt>
<dd>: This should be a MemoryMappedIO - needs <a class="el" href="classVirtualAddressSpace.html">VirtualAddressSpace</a> though.  </dd>
<dt><a class="anchor" id="_todo000522"></a>Class <a class="el" href="classPrcm.html">Prcm</a>  </dt>
<dd><p class="startdd">Power management </p>
<p class="enddd">Reset  </p>
</dd>
<dt><a class="anchor" id="_todo000519"></a>Member <a class="el" href="classPrcm.html#ad79e8556097fcd8ea5ac9b57fb1dd05d">Prcm::initialise</a>  (uintptr_t base)</dt>
<dd>Proper initialisation  </dd>
<dt><a class="anchor" id="_todo000520"></a>Member <a class="el" href="classPrcm.html#a8863c712f6c6d3ba48eed0f536f6b69a">Prcm::WaitCoreIdleStatus</a>  (size_t n, size_t clock, bool waitForOn)</dt>
<dd>delays or something  </dd>
<dt><a class="anchor" id="_todo000521"></a>Member <a class="el" href="classPrcm.html#a702f8acac4bccaff0180c32b72860564">Prcm::WaitPllIdleStatus</a>  (size_t n, size_t clock, bool waitForOn)</dt>
<dd>delays or something  </dd>
<dt><a class="anchor" id="_todo000433"></a>Member <a class="el" href="classProcessor.html#ae2744712af3306e1fe1c94c2dbb050b5">Processor::disableDebugBreakpoint</a>  (size_t nBpNumber)</dt>
<dd><p class="startdd">Implement. </p>
<p class="enddd">Implement.  </p>
</dd>
<dt><a class="anchor" id="_todo000432"></a>Member <a class="el" href="classProcessor.html#a4a22397f24e62542351fb1103ec2df20">Processor::enableDebugBreakpoint</a>  (size_t nBpNumber, uintptr_t nLinearAddress, DebugFlags::FaultType nFaultType, size_t nLength)</dt>
<dd><p class="startdd">Implement. </p>
<p class="enddd">Implement.  </p>
</dd>
<dt><a class="anchor" id="_todo000431"></a>Member <a class="el" href="classProcessor.html#a24667e67f01364e9511112385ebcaecf">Processor::getDebugBreakpoint</a>  (size_t nBpNumber, DebugFlags::FaultType &amp;nFaultType, size_t &amp;nLength, bool &amp;bEnabled)</dt>
<dd><p class="startdd">Implement. </p>
<p class="enddd">Implement.  </p>
</dd>
<dt><a class="anchor" id="_todo000398"></a>Member <a class="el" href="classProcessor.html#a77ada3d70badfd690317c13337070db4">Processor::getDebugStatus</a>  ()</dt>
<dd>is the debug status somehow abtractable?  </dd>
<dt><a class="anchor" id="_todo000454"></a>Member <a class="el" href="classProcessor.html#a652bf7e9883ac20b0c861a94937e6782">Processor::getInterrupts</a>  ()</dt>
<dd>FIQs count too  </dd>
<dt><a class="anchor" id="_todo000502"></a>Member <a class="el" href="classProcessor.html#a2da3d5f8b642203eb82aa9a183e00aa9">Processor::initialisationDone</a>  ()</dt>
<dd>there HAS to be a better way than this  </dd>
<dt><a class="anchor" id="_todo000449"></a>Member <a class="el" href="classProcessor.html#a9eba0725a01c97828d5e55b9c09bbd32">Processor::initialise1</a>  (const <a class="el" href="structBootstrapStruct__t.html" title="Bootstrap structure passed to the kernel entry point. ">BootstrapStruct_t</a> &amp;Info) INITIALISATION_ONLY</dt>
<dd>Unmap.  </dd>
<dt><a class="anchor" id="_todo000399"></a>Member <a class="el" href="classProcessor.html#a8fbccf6b391a669ac7b2401aa8568ae4">Processor::invalidate</a>  (void *pAddress)</dt>
<dd>Figure out if we want to flush the TLB of every processor or if this should be handled by the upper layers  </dd>
<dt><a class="anchor" id="_todo000434"></a>Member <a class="el" href="classProcessor.html#a1d69a878813795c4e0b0587690c50cd1">Processor::setInterrupts</a>  (bool bEnable)</dt>
<dd><p class="startdd">Implement. </p>
<p class="enddd">FIQs count too  </p>
</dd>
<dt><a class="anchor" id="_todo000435"></a>Member <a class="el" href="classProcessor.html#ae98d14c9118543fbc3756a8969f7abf8">Processor::setSingleStep</a>  (bool bEnable, InterruptState &amp;state)</dt>
<dd><p class="startdd">Implement </p>
<p>Implement </p>
<p class="enddd">Implement - MIPS doesn't have a single step mechanism per se...  </p>
</dd>
<dt><a class="anchor" id="_todo000220"></a>Member <a class="el" href="classProcFs.html#ae7d25ba8c140ff723b620c8be87ab05e">ProcFs::addProcess</a>  (<a class="el" href="classPosixProcess.html">PosixProcess</a> *proc)</dt>
<dd><p class="startdd">is this correct? or should it be effective user/group? </p>
<p class="enddd">add some info to the directory...  </p>
</dd>
<dt><a class="anchor" id="_todo000216"></a>Member <a class="el" href="classProcFs.html#ae9c6292f109e70f1513691d850b8e721">ProcFs::initialise</a>  (<a class="el" href="classDisk.html">Disk</a> *pDisk)</dt>
<dd><p class="startdd">need to know parent (if any) so we can add dotdot too </p>
<p>also probably need /etc/mtab... </p>
<p>need to add some flags here </p>
<p class="enddd">add driver name here if known?  </p>
</dd>
<dt><a class="anchor" id="_todo000222"></a>Member <a class="el" href="classProcFs.html#a91605b839e263a4ccbe5da448feccedd">ProcFs::removeProcess</a>  (<a class="el" href="classPosixProcess.html">PosixProcess</a> *proc)</dt>
<dd>should also remove all the files/directories in the directory  </dd>
<dt><a class="anchor" id="_todo000559"></a>Member <a class="el" href="classProducerConsumer.html#a13404fb2d405ccfe688058bab5a7a8c2">ProducerConsumer::consumerThread</a>  ()</dt>
<dd>should really use the result here.  </dd>
<dt><a class="anchor" id="_todo000542"></a>Member <a class="el" href="classPs2Controller.html#a8a5f3a24f48afc2b4f4b97b5f0ce94a6">Ps2Controller::sendCommandWithResponse</a>  (uint8_t command, uint8_t data)</dt>
<dd>handle this when we have irqs enabled  </dd>
<dt><a class="anchor" id="_todo000541"></a>Member <a class="el" href="classPs2Controller.html#acd23cbe561841c6b4d017d06bb1064c2">Ps2Controller::sendCommandWithResponse</a>  (uint8_t command)</dt>
<dd>handle this when we have irqs enabled  </dd>
<dt><a class="anchor" id="_todo000061"></a>Member <a class="el" href="classPs2Mouse.html#afc4f5a7510f1720f7078ec1cff05d46f">Ps2Mouse::initialise</a>  (<a class="el" href="classPs2Controller.html">Ps2Controller</a> *pController)</dt>
<dd>handle errors, resend requests, etc  </dd>
<dt><a class="anchor" id="_todo000105"></a>Member <a class="el" href="classPtmxFile.html#a88a15b1df089d505a26eff392806de9f">PtmxFile::open</a>  ()</dt>
<dd>so, when this master is closed, we'll leak these resources...  </dd>
<dt><a class="anchor" id="_todo000405"></a>Member <a class="el" href="group__kernelutilities.html#ga21a07a69a7f54379958db3fa0da96a08">RadixTree&lt; T &gt;::operator=</a>  (const <a class="el" href="classRadixTree.html" title="A key/value dictionary for string keys. ">RadixTree</a> &amp;x)</dt>
<dd>check for incompatible case-sensitivity?  </dd>
<dt><a class="anchor" id="_todo000347"></a>Member <a class="el" href="classRamFile.html#af3a8c603134fef22a1f6629e3f27682b">RamFile::readBlock</a>  (uint64_t location)</dt>
<dd>Kind of irrelevant here?  </dd>
<dt><a class="anchor" id="_todo000104"></a>Member <a class="el" href="classRandomFile.html#a056d0d51557bded3341b166f9c0bc922">RandomFile::readBytewise</a>  (uint64_t location, uint64_t size, uintptr_t buffer, bool bCanBlock=true)</dt>
<dd>Endianness issues?  </dd>
<dt><a class="anchor" id="_todo000349"></a>Member <a class="el" href="classRawFsDir.html#ad0064a2367360f81ad37137d9edb1021">RawFsDir::removeRecursive</a>  ()</dt>
<dd><p class="startdd">Leaky. </p>
<p class="enddd">do this  </p>
</dd>
<dt><a class="anchor" id="_todo000560"></a>Member <a class="el" href="classRequestQueue.html#ad7f0619cef08f169ae7a0ee69140e56b">RequestQueue::getNextRequest</a>  ()</dt>
<dd>Stop possible starvation here.  </dd>
<dt><a class="anchor" id="_todo000561"></a>Member <a class="el" href="classRequestQueue.html#a5313c0734674cc9644f6365e9fdcab11">RequestQueue::work</a>  ()</dt>
<dd>should handle errors properly here  </dd>
<dt><a class="anchor" id="_todo000408"></a>Member <a class="el" href="classRingBuffer.html#a404a63ab677e244d13fabf3adfaf208a">RingBuffer&lt; T &gt;::read</a>  (Time::Timestamp &amp;timeout)</dt>
<dd>need to allow read() to fail - use Result&lt;&gt;  </dd>
<dt><a class="anchor" id="_todo000407"></a>Member <a class="el" href="classRingBuffer.html#a2f0fb5c7798f179622eb6b73f041fe95">RingBuffer&lt; T &gt;::write</a>  (const T &amp;obj, Time::Timestamp &amp;timeout)</dt>
<dd>oh dear, writes are always assumed to succeed  </dd>
<dt><a class="anchor" id="_todo000406"></a>Namespace <a class="el" href="namespaceRingBufferWait.html">RingBufferWait</a>  </dt>
<dd>rewrite this in the same way as TcpBuffer!  </dd>
<dt><a class="anchor" id="_todo000545"></a>Member <a class="el" href="classRtc.html#a6317e6af2113d58242222378c8b90a0a">Rtc::irq</a>  (irq_id_t number, InterruptState &amp;state)</dt>
<dd>figure out how best to handle this  </dd>
<dt><a class="anchor" id="_todo000544"></a>Member <a class="el" href="classRtc.html#a4d36d024531285c9cc5b3a2b23a3dcc9">Rtc::removeAlarm</a>  (class <a class="el" href="classEvent.html">Event</a> *pEvent, bool bRetZero)</dt>
<dd>clarify units  </dd>
<dt><a class="anchor" id="_todo000046"></a>Member <a class="el" href="classScsiDisk.html#a05d49088a52603f014b7cd21a6ef92b2">ScsiDisk::doRead</a>  (uint64_t location)</dt>
<dd><p class="startdd"><a class="el" href="classCache.html">Cache</a> this somewhere. </p>
<p class="enddd">endianness issue?  </p>
</dd>
<dt><a class="anchor" id="_todo000043"></a>Member <a class="el" href="classScsiDisk.html#a088d1e4d920da494212a9a37f3bde01c">ScsiDisk::initialise</a>  (class <a class="el" href="classScsiController.html">ScsiController</a> *pController, size_t nUnit)</dt>
<dd>Use this data to change how <a class="el" href="classScsiDisk.html#a3f3bb7aea858a2aecd991e53a1f1d3ca">read()</a> and <a class="el" href="classScsiDisk.html#a35c2d6efbc45c8d5862f81b36956558c">write()</a> work  </dd>
<dt><a class="anchor" id="_todo000044"></a>Member <a class="el" href="classScsiDisk.html#a1ca91c18455874cb71055d1604316d95">ScsiDisk::readSense</a>  (<a class="el" href="structScsiDisk_1_1Sense.html">Sense</a> *s)</dt>
<dd>get the amount of data received from the SCSI device  </dd>
<dt><a class="anchor" id="_todo000045"></a>Member <a class="el" href="classScsiDisk.html#a97c7c412431a5c208560370c6a600e01">ScsiDisk::unitReady</a>  ()</dt>
<dd>this can fail with UNIT_ATTN or NOT_READY if the device is removable.  </dd>
<dt><a class="anchor" id="_todo000391"></a>Member <a class="el" href="classSerial.html#a4fd060ab70af68728d44662ef8dce745">Serial::setBase</a>  (uintptr_t nBaseAddr)=0</dt>
<dd>make this generic for Mmaped and port IO.  </dd>
<dt><a class="anchor" id="_todo000507"></a>Member <a class="el" href="classSerialIO.html#a3e9125405e364caac874b571c7a02ea1">SerialIO::putChar</a>  (char c, <a class="el" href="classDebuggerIO.html#a7851f85f5272bd53c5d2c638b65125a9">DebuggerIO::Colour</a> foreColour, <a class="el" href="classDebuggerIO.html#a7851f85f5272bd53c5d2c638b65125a9">DebuggerIO::Colour</a> backColour)</dt>
<dd>This code below is costly and slow, but without it we can't line-wrap. Sort this out.  </dd>
<dt><a class="anchor" id="_todo000400"></a>Class <a class="el" href="classService.html">Service</a>  </dt>
<dd>Integrate with the <a class="el" href="classEvent.html">Event</a> system somehow  </dd>
<dt><a class="anchor" id="_todo000401"></a>Class <a class="el" href="classServiceManager.html">ServiceManager</a>  </dt>
<dd>Integrate with the <a class="el" href="classEvent.html">Event</a> system somehow  </dd>
<dt><a class="anchor" id="_todo000550"></a>Member <a class="el" href="classServiceManager.html#a87b207df58ccd316320d490c003c7eda">ServiceManager::~ServiceManager</a>  ()</dt>
<dd>Delete all the pointers!  </dd>
<dt><a class="anchor" id="_todo000579"></a>Member <a class="el" href="classSharedBuffer.html#afe0aa7fb5edc8450c34c857e8f66fae0">SharedBuffer::~SharedBuffer</a>  ()</dt>
<dd>Need a way to destroy the old framebuffer without freeing the shared region. Refcount on the region perhaps?  </dd>
<dt><a class="anchor" id="_todo000409"></a>Member <a class="el" href="classSharedPointer.html#a8f1b6ee5e89319193ff68751ce67854f">SharedPointer&lt; T &gt;::release</a>  ()</dt>
<dd>allow specifying a custom function to handle deletion  </dd>
<dt><a class="anchor" id="_todo000423"></a>Member <a class="el" href="classSignalEvent.html#a7e2b3e0eb4c2ce25d4bfbf1ceb41ce29">SignalEvent::serialize</a>  (uint8_t *pBuffer)</dt>
<dd>There may be a need for serialization in the future...  </dd>
<dt><a class="anchor" id="_todo000387"></a>Member <a class="el" href="classSlamAllocator.html#accd34a86d0156a16fff1ca5e76963cf9">SlamAllocator::m_Instance</a>  </dt>
<dd>why does a module access this!?  </dd>
<dt><a class="anchor" id="_todo000402"></a>Member <a class="el" href="classSpinlock.html#a41974138bd7172a4e907cbafc3bfbf05">Spinlock::m_CpuState</a>  </dt>
<dd>handle more than 64 CPUs.  </dd>
<dt><a class="anchor" id="_todo000411"></a>Member <a class="el" href="classStaticString.html#a237ee8108b76b58a126cb8110eb21f16">StaticString&lt; N &gt;::append</a>  (const char *str, size_t nLen=0, char c= ' ')</dt>
<dd>this is unsafe - StringLength is unconstrained.  </dd>
<dt><a class="anchor" id="_todo000410"></a>Member <a class="el" href="classStaticString.html#abe162de1b882a34af4309495b2583bc7">StaticString&lt; N &gt;::right</a>  (int n) const </dt>
<dd>this is technically off-by-one, but I don't feel comfortable changing the behavior -Matt  </dd>
<dt><a class="anchor" id="_todo000412"></a>Class <a class="el" href="classString.html">String</a>  </dt>
<dd>provide documentation  </dd>
<dt><a class="anchor" id="_todo000562"></a>Member <a class="el" href="classString.html#ad89bf1680136e35ef8284d9ee465c526">String::find</a>  (const char c) const </dt>
<dd>this problem only exists because we use return -1 as a status indicator. That could be changed, and we could avoid a signed/unsigned conversion here!  </dd>
<dt><a class="anchor" id="_todo000340"></a>Member <a class="el" href="group__sys__misc.html#ga0d596afdd8dbcfad320172d39b0f607a">sys_thread_new</a>  (const char *name, lwip_thread_fn thread, void *arg, int stacksize, int prio)</dt>
<dd>stacksize might be important  </dd>
<dt><a class="anchor" id="_todo000591"></a>Member <a class="el" href="classTerminal.html#a02a6f98e9a31ab7664b40314e6409b05">Terminal::initialise</a>  ()</dt>
<dd>Clean it up when the child terminates.  </dd>
<dt><a class="anchor" id="_todo000592"></a>Member <a class="el" href="classTerminal.html#ad22eba987a71544b113bfa9a7b1007bd">Terminal::renewBuffer</a>  (size_t nWidth, size_t nHeight)</dt>
<dd>Send SIGWINCH in console layer.  </dd>
<dt><a class="anchor" id="_todo000593"></a>Member <a class="el" href="classTerminal.html#af021a96795519940eb8fbf648479f028">Terminal::write</a>  (const char *pStr, <a class="el" href="classDirtyRectangle.html">DirtyRectangle</a> &amp;rect)</dt>
<dd>Add some checking - every successive byte should start with 0b10.  </dd>
<dt><a class="anchor" id="_todo000277"></a>Member <a class="el" href="classTextIO.html#a49c5564ff82cf9a087c7e89493dddd35">TextIO::writeStr</a>  (const char *s, size_t len)</dt>
<dd><p class="startdd">Should we handle this? </p>
<p>hook in to <a class="el" href="classKeyboard.html#aac7dc2104e64da0328d1ab7e71efdfab">Keyboard::setLedState</a>! </p>
<p>Sanity check. </p>
<p>Error out if is Utf8 </p>
<p>implement me! </p>
<p class="enddd">implement me!  </p>
</dd>
<dt><a class="anchor" id="_todo000392"></a>Member <a class="el" href="classThread.html#a527a69e624f1357a03e588a2816a3006">Thread::pushState</a>  ()</dt>
<dd><p class="startdd">This should also push errno and m_bInterrupted, so syscalls can be used safely in interrupt handlers.</p>
<p class="enddd">Take some action here - possibly kill the thread?  </p>
</dd>
<dt><a class="anchor" id="_todo000427"></a>Member <a class="el" href="classThread.html#ad1455ad5719b52f45993565b28e649ba">Thread::sendEvent</a>  (<a class="el" href="classEvent.html">Event</a> *pEvent)</dt>
<dd>we should be checking inhibits HERE! so we don't wake a thread that has inhibited the sent event  </dd>
<dt><a class="anchor" id="_todo000425"></a>Member <a class="el" href="classThread.html#aa4f074ab1a92785a1f08fa2b01d2611f">Thread::setStatus</a>  (Status s)</dt>
<dd>provide a way to report this in <a class="el" href="classThread.html#aa4f074ab1a92785a1f08fa2b01d2611f">Thread::setStatus</a> API  </dd>
<dt><a class="anchor" id="_todo000428"></a>Member <a class="el" href="classThread.html#a191d1aa798e703b5b9458b6559eb414c">Thread::setTlsBase</a>  (uintptr_t base)</dt>
<dd>clean up old base  </dd>
<dt><a class="anchor" id="_todo000424"></a>Member <a class="el" href="classThread.html#a4b9ca8bc69c36ab5c19fa99972ba2c2e">Thread::shutdown</a>  ()</dt>
<dd>identify a way to make cleanup work here.  </dd>
<dt><a class="anchor" id="_todo000393"></a>Class <a class="el" href="classThreadToCoreAllocationAlgorithm.html">ThreadToCoreAllocationAlgorithm</a>  </dt>
<dd>Document.  </dd>
<dt><a class="anchor" id="_todo000468"></a>Member <a class="el" href="classTranslations.html#a82a55e193b853511f92770d48147f85d">Translations::findFreePhysicalMemory</a>  (uint32_t size, uint32_t align=0x100000)</dt>
<dd>Buggy, I think.  </dd>
<dt><a class="anchor" id="_todo000413"></a>Class <a class="el" href="classTree_1_1IteratorNode.html">Tree&lt; K, E &gt;::IteratorNode</a>  </dt>
<dd>This will actually mean for each <a class="el" href="classTree.html" title="A key/value dictionary. ">Tree</a> you can only use one iterator at a time, which may not be effective depending on how this is used.  </dd>
<dt><a class="anchor" id="_todo000266"></a>Member <a class="el" href="classUnixSocket.html#a4158645e201be3e343ce927d776a9867">UnixSocket::~UnixSocket</a>  ()</dt>
<dd>update read/write to handle the other socket going away correctly  </dd>
<dt><a class="anchor" id="_todo000189"></a>Member <a class="el" href="classUnixSocketSyscalls.html#a48974c15d8b4e853ed6ffd6485b21ddc">UnixSocketSyscalls::bind</a>  (const struct sockaddr *address, socklen_t addrlen)</dt>
<dd><p class="startdd">unbind existing socket if one exists. </p>
<p>re-bind an unnamed address if we are bound already </p>
<p>does this actually create a findable file? </p>
<p class="enddd">errno?  </p>
</dd>
<dt><a class="anchor" id="_todo000180"></a>Member <a class="el" href="classUnixSocketSyscalls.html#a4baea46f8944d4b959bcf46b99e9472e">UnixSocketSyscalls::connect</a>  (const struct sockaddr *address, socklen_t addrlen)</dt>
<dd>wrong error  </dd>
<dt><a class="anchor" id="_todo000188"></a>Member <a class="el" href="classUnixSocketSyscalls.html#a126a558224dee5447e30c500a4f06812">UnixSocketSyscalls::listen</a>  (int backlog)</dt>
<dd>bind to an unnamed socket if we aren't already bound  </dd>
<dt><a class="anchor" id="_todo000186"></a>Member <a class="el" href="classUnixSocketSyscalls.html#a42b6f8136053b59cb8e2deef04d42746">UnixSocketSyscalls::recvfrom_msg</a>  (struct msghdr *msghdr)</dt>
<dd><p class="startdd">get info from the socket about things like truncated buffer </p>
<p class="enddd">except that it could be.. need to detect <a class="el" href="classUnixSocketSyscalls.html#a771088db5764b5d9aaf0490f794d8e75">shutdown()</a>  </p>
</dd>
<dt><a class="anchor" id="_todo000181"></a>Member <a class="el" href="classUnixSocketSyscalls.html#a894d6c12d21ffc3588847ecbed648fcc">UnixSocketSyscalls::sendto_msg</a>  (const struct msghdr *msghdr)</dt>
<dd><p class="startdd">this doesn't handle a connection going away - only a connection not being made in the first place (I think it's a different errno) </p>
<p>errno </p>
<p>needs some sort of errno here </p>
<p>wrong error </p>
<p class="enddd">except that it could be.. need to detect <a class="el" href="classUnixSocketSyscalls.html#a771088db5764b5d9aaf0490f794d8e75">shutdown()</a>  </p>
</dd>
<dt><a class="anchor" id="_todo000193"></a>Member <a class="el" href="classUnixSocketSyscalls.html#a771088db5764b5d9aaf0490f794d8e75">UnixSocketSyscalls::shutdown</a>  (int how)</dt>
<dd></dd>
<dt><a class="anchor" id="_todo000179"></a>Member <a class="el" href="classUnixSocketSyscalls.html#a8c6242d83c86576cf71ed4d4e95d5243">UnixSocketSyscalls::~UnixSocketSyscalls</a>  ()</dt>
<dd>should <a class="el" href="classUnixSocketSyscalls.html#a771088db5764b5d9aaf0490f794d8e75">shutdown()</a> which should wake up recv() or poll()  </dd>
<dt><a class="anchor" id="_todo000364"></a>Member <a class="el" href="classUsbDevice.html#a9f1216317173a1a536b72c9b64e3e4f8">UsbDevice::getDescriptor</a>  (uint8_t nDescriptorType, uint8_t nDescriptorIndex, uint16_t nBytes, uint8_t requestType=0)</dt>
<dd>Proper language ID handling!  </dd>
<dt><a class="anchor" id="_todo000365"></a>Member <a class="el" href="classUsbDevice.html#a9534ef2fa9f624721fc64375c16a069a">UsbDevice::getDescriptorLength</a>  (uint8_t nDescriptorType, uint8_t nDescriptorIndex, uint8_t requestType=0)</dt>
<dd>Proper language ID handling  </dd>
<dt><a class="anchor" id="_todo000366"></a>Member <a class="el" href="classUsbDevice.html#a82e4765d61c2b20c328d0ea3cbba5bbc">UsbDevice::getString</a>  (uint8_t nString)</dt>
<dd>UTF-8 support of some kind  </dd>
<dt><a class="anchor" id="_todo000362"></a>Member <a class="el" href="classUsbDevice.html#ac0abfedd23074e8a6f0bbe5fb292dd69">UsbDevice::initialise</a>  (uint8_t nAddress)</dt>
<dd><p class="startdd">This doesn't work - HS devices at FS stall all over the place. Find out why. </p>
<p class="enddd">support more configurations (how?)  </p>
</dd>
<dt><a class="anchor" id="_todo000054"></a>Member <a class="el" href="classUsbMassStorageDevice.html#a89414bd660a46eb55aa15b4663f34210">UsbMassStorageDevice::initialiseDriver</a>  ()</dt>
<dd>Some mass storage devices don't support this command, fail to return logical information, or just report incorrect data. All that needs to be handled.  </dd>
<dt><a class="anchor" id="_todo000055"></a>Member <a class="el" href="classUsbMassStorageDevice.html#a0c67064650c95be7c655a821c7e79e21">UsbMassStorageDevice::sendCommand</a>  (size_t nUnit, uintptr_t pCommand, uint8_t nCommandSize, uintptr_t pRespBuffer, uint16_t nRespBytes, bool bWrite)</dt>
<dd><p class="startdd">Should probably just be transaction errors and stalls </p>
<p class="enddd">Should probably just be transaction errors and stalls  </p>
</dd>
<dt><a class="anchor" id="_todo000003"></a>Member <a class="el" href="classUsbUlpi.html#a623eb34991ca147b6f9e4281977882ed">UsbUlpi::initialise</a>  ()</dt>
<dd>OtgControl is invalid on Linaro's beaglexm qemu emulation.  </dd>
<dt><a class="anchor" id="_todo000002"></a>Member <a class="el" href="classUsbUlpi.html#a522384bae5bf1b989725be354c54ed6d">UsbUlpi::m_Instance</a>  </dt>
<dd>super specific to a machine  </dd>
<dt><a class="anchor" id="_todo000064"></a>Member <a class="el" href="classVbeDisplay.html#a94aebe24e2c0d8651d8ff1fecfe67397">VbeDisplay::fillRectangle</a>  (<a class="el" href="structrgb__t.html">rgb_t</a> *pBuffer, size_t x, size_t y, size_t width, size_t height, <a class="el" href="structrgb__t.html">rgb_t</a> colour)</dt>
<dd>This needs to properly handle the case where there's more than one byte per pixel? (or less, I guess)  </dd>
<dt><a class="anchor" id="_todo000063"></a>Member <a class="el" href="classVbeDisplay.html#ade3f4466a4d380c97c023c71555d2c38">VbeDisplay::setScreenMode</a>  (<a class="el" href="structDisplay_1_1ScreenMode.html">Display::ScreenMode</a> sm)</dt>
<dd>Assumption may be wrong?  </dd>
<dt><a class="anchor" id="_todo000383"></a>Member <a class="el" href="classVFS.html#a332ad26a80d1e3d4055afda08311f841">VFS::m_Instance</a>  </dt>
<dd>Figure out a way to clean up files after deletion. <a class="el" href="classDirectory.html#a7426726ec5606e1f78b8f9691621902b">Directory::remove()</a> is not the right place to do this. There needs to be a way to add a <a class="el" href="classFile.html">File</a> to some sort of queue that cleans it up once it hits refcount zero or something like that.  </dd>
<dt><a class="anchor" id="_todo000384"></a>Member <a class="el" href="classVFS.html#ac779c4b90c904c303f66fecc67f9a42e">VFS::removeAlias</a>  (const <a class="el" href="classString.html">String</a> &amp;alias)</dt>
<dd>Remove from m_Mounts  </dd>
<dt><a class="anchor" id="_todo000385"></a>Member <a class="el" href="classVFS.html#aad66a3585e8ceb2c742e43a6daa35ee9">VFS::removeAllAliases</a>  (<a class="el" href="classFilesystem.html">Filesystem</a> *pFs, bool canDelete=true)</dt>
<dd>Locking.  </dd>
<dt><a class="anchor" id="_todo000268"></a>Member <a class="el" href="classVirtualTerminalManager.html#a41d7ba89bf2a0a4387e518a6e99d8c61">VirtualTerminalManager::getTerminalMode</a>  (size_t n) const </dt>
<dd>validate n  </dd>
<dt><a class="anchor" id="_todo000269"></a>Member <a class="el" href="classVirtualTerminalManager.html#a1b146be19b417290c7d060628bd8d2da">VirtualTerminalManager::setTerminalMode</a>  (size_t n, struct <a class="el" href="structvt__mode.html">vt_mode</a> mode)</dt>
<dd>validate n  </dd>
<dt><a class="anchor" id="_todo000066"></a>Member <a class="el" href="classVmwareGraphics.html#a96f943b65b6844cbfc313d9c09df6722">VmwareGraphics::getCurrentScreenMode</a>  (<a class="el" href="structDisplay_1_1ScreenMode.html">Display::ScreenMode</a> &amp;sm)</dt>
<dd>Not necessarily always correct for boundary cases  </dd>
<dt><a class="anchor" id="_todo000068"></a>Member <a class="el" href="classVmwareGraphics.html#a47fc580b98135d0908abdfa63f49ab6b">VmwareGraphics::readRegister</a>  (size_t offset)</dt>
<dd>Lock these  </dd>
<dt><a class="anchor" id="_todo000067"></a>Member <a class="el" href="classVmwareGraphics.html#a0451428566decb46592d729984fad72f">VmwareGraphics::setMode</a>  (size_t w, size_t h, size_t bpp)</dt>
<dd>If we switch to any mode after the first one has been set, the old region needs to be deallocated.  </dd>
<dt><a class="anchor" id="_todo000069"></a>Member <a class="el" href="classVmwareGraphics_1_1VmwareFramebuffer.html#aab5d55da0f3c58b8cca068229a5d805d">VmwareGraphics::VmwareFramebuffer::copy</a>  (size_t srcx, size_t srcy, size_t destx, size_t desty, size_t w, size_t h, bool bLowestCall=true)</dt>
<dd>Caps to determine whether to fall back to software  </dd>
<dt><a class="anchor" id="_todo000473"></a>Member <a class="el" href="classVsidManager.html#ac2e4aef776cf58041bc8b96f21740874">VsidManager::obtainVsid</a>  ()</dt>
<dd>Locking  </dd>
<dt><a class="anchor" id="_todo000474"></a>Member <a class="el" href="classVsidManager.html#acd6d3890b6fc641c739136a5bf11272a">VsidManager::returnVsid</a>  (Vsid vsid)</dt>
<dd><p class="startdd">Locking </p>
<p class="enddd">decrement high water mark if possible  </p>
</dd>
<dt><a class="anchor" id="_todo000610"></a>Member <a class="el" href="classWidget.html#a4b903f1f2ca9f034c2259fe8a766a84a">Widget::construct</a>  (const char *endpoint, const char *title, widgetCallback_t cb, <a class="el" href="classPedigreeGraphics_1_1Rect.html">PedigreeGraphics::Rect</a> &amp;dimensions)</dt>
<dd>Maybe we can get a decent way of having a default handler?  </dd>
<dt><a class="anchor" id="_todo000611"></a>Member <a class="el" href="classWidget.html#a9f65838eb063a9d2b264d757f996533f">Widget::destroy</a>  ()</dt>
<dd>do we care if the send fails? We probably do??  </dd>
<dt><a class="anchor" id="_todo000577"></a>Member <a class="el" href="classWindow.html#a245d821e6016fa1f6970ccbbedd635f6">Window::~Window</a>  ()</dt>
<dd>Need a way to destroy the old framebuffer without breaking the other side's reference to the same region... Refcount?  </dd>
<dt><a class="anchor" id="_todo000477"></a>Member <a class="el" href="classX64GdtManager.html#aaf90b5cd2e648e88aa4c0c4379905f7d">X64GdtManager::initialiseProcessor</a>  () INITIALISATION_ONLY</dt>
<dd>and some smp/acpi function  </dd>
<dt><a class="anchor" id="_todo000476"></a>Member <a class="el" href="classX64GdtManager.html#ac7705f3336fbe0624e63b7224f5d4ecf">X64GdtManager::initialiseTss</a>  (<a class="el" href="structX64TaskStateSegment.html">X64TaskStateSegment</a> *pTss) INITIALISATION_ONLY</dt>
<dd>this should change  </dd>
<dt><a class="anchor" id="_todo000480"></a>Member <a class="el" href="classX64SyscallManager.html#acc6d2a6f62248597862e88f1e50a06aa">X64SyscallManager::syscall</a>  (SyscallState &amp;syscallState) USED</dt>
<dd>this is an extraordinary hack, this should be done in a way more abstract way than this!!  </dd>
<dt><a class="anchor" id="_todo000486"></a>Member <a class="el" href="classX64VirtualAddressSpace.html#a90c94c03e1163511566d1d25e6360693">X64VirtualAddressSpace::clone</a>  (bool copyOnWrite=true)</dt>
<dd><p class="startdd">figure out how to handle page tracking here </p>
<p class="enddd">Deal with 2MB pages here.  </p>
</dd>
<dt><a class="anchor" id="_todo000481"></a>Member <a class="el" href="classX64VirtualAddressSpace.html#a4c35909ffe022c9ad67369ca849e9b44">X64VirtualAddressSpace::mapHuge</a>  (physical_uintptr_t physAddress, void *virtualAddress, size_t count, size_t flags)</dt>
<dd><p class="startdd">this does not handle non-1G-aligned counts. </p>
<p>we should unmap everything in the region first, clean up tables etc </p>
<p>change define to mean huge </p>
<p class="enddd">sanity check physical address?  </p>
</dd>
<dt><a class="anchor" id="_todo000485"></a>Member <a class="el" href="classX64VirtualAddressSpace.html#add398c3f401ddbb77c958855e13f2ee4">X64VirtualAddressSpace::mapUnlocked</a>  (physical_uintptr_t physAddress, void *virtualAddress, size_t flags, bool locked=false)</dt>
<dd>this can actually break if a process is removed from the scheduler while we iterate!  </dd>
<dt><a class="anchor" id="_todo000488"></a>Member <a class="el" href="classX64VirtualAddressSpace.html#a58a150db2fad1986f983e6da6e496dc8">X64VirtualAddressSpace::revertToKernelAddressSpace</a>  ()</dt>
<dd><p class="startdd">Deal with 2MB pages here. </p>
<p class="enddd">When swap system comes along, we want to remove this page from swap!  </p>
</dd>
<dt><a class="anchor" id="_todo000490"></a>Member <a class="el" href="classX64VirtualAddressSpace.html#ac6ca1b8304bedd42eecbf52016aa6a62">X64VirtualAddressSpace::~X64VirtualAddressSpace</a>  ()</dt>
<dd>validate that we're cleaning up enough stuff here for example are we missing stuff like PDPTs etc?  </dd>
<dt><a class="anchor" id="_todo000497"></a>Member <a class="el" href="classX86CommonPhysicalMemoryManager.html#a82e43fa6fd96b14243350b2edc1bbc61">X86CommonPhysicalMemoryManager::initialise</a>  (const <a class="el" href="structBootstrapStruct__t.html" title="Bootstrap structure passed to the kernel entry point. ">BootstrapStruct_t</a> &amp;Info) INITIALISATION_ONLY</dt>
<dd>do this in initialise64 too, copying any existing entries.  </dd>
<dt><a class="anchor" id="_todo000498"></a>Member <a class="el" href="classX86CommonPhysicalMemoryManager.html#a2fd295a1c9d12b6713476e4337d20e25">X86CommonPhysicalMemoryManager::initialise64</a>  (const <a class="el" href="structBootstrapStruct__t.html" title="Bootstrap structure passed to the kernel entry point. ">BootstrapStruct_t</a> &amp;Info) INITIALISATION_ONLY</dt>
<dd>this will break if there's over 64 TiB of RAM on the machine.  </dd>
<dt><a class="anchor" id="_todo000501"></a>Member <a class="el" href="classX86CommonPhysicalMemoryManager.html#a3e7777777c22a43cf682138aa9f734b0">X86CommonPhysicalMemoryManager::m_MemoryRegions</a>  </dt>
<dd>rename this member (conflicts with <a class="el" href="classPhysicalMemoryManager.html#adcab0a2f52ba2ec74476a04515c8ba8e">PhysicalMemoryManager::m_MemoryRegions</a>)  </dd>
<dt><a class="anchor" id="_todo000500"></a>Member <a class="el" href="classX86CommonPhysicalMemoryManager_1_1PageStack.html#aa37d4204840587cde5918860dcd2fbd5">X86CommonPhysicalMemoryManager::PageStack::free</a>  (uint64_t physicalAddress, size_t length)</dt>
<dd>make sure callers split any regions that cross over before calling  </dd>
<dt><a class="anchor" id="_todo000499"></a>Member <a class="el" href="classX86CommonPhysicalMemoryManager.html#a6a84e68afeff519cbcb3c12e290c118a">X86CommonPhysicalMemoryManager::unmapRegion</a>  (<a class="el" href="classMemoryRegion.html" title="Special memory entity in the kernel&#39;s virtual address space. ">MemoryRegion</a> *pRegion)</dt>
<dd>copy the pageConstraints to the Region object  </dd>
<dt><a class="anchor" id="_todo000491"></a>Member <a class="el" href="classX86GdtManager.html#a9f9eaac9adbcbc67f7fb8599d8337be6">X86GdtManager::initialiseProcessor</a>  () INITIALISATION_ONLY</dt>
<dd>and some smp/acpi function  </dd>
<dt><a class="anchor" id="_todo000038"></a>Member <a class="el" href="classX86IsaDma.html#a23e2457615deb940d6a0ebedb89446eb">X86IsaDma::initTransfer</a>  (uint8_t channel, uint8_t mode, size_t length, uintptr_t addr)</dt>
<dd>Extra flags to control modes and things  </dd>
<dt><a class="anchor" id="_todo000494"></a>Member <a class="el" href="classX86KernelVirtualAddressSpace.html#a95f71201762ceb8df9959048c4098599">X86KernelVirtualAddressSpace::m_Instance</a>  </dt>
<dd>MAX_PROCESSORS  </dd>
<dt><a class="anchor" id="_todo000496"></a>Member <a class="el" href="classX86KernelVirtualAddressSpace.html#acadb9382c599476a5ebbd0ca98bb0186">X86KernelVirtualAddressSpace::X86KernelVirtualAddressSpace</a>  ()</dt>
<dd>MAX_PROCESSORS here.  </dd>
<dt><a class="anchor" id="_todo000540"></a>Member <a class="el" href="classX86Keyboard.html#a96962b8cee3805e08f7fefe361bd112b">X86Keyboard::initialise</a>  ()</dt>
<dd>do we need to switch into a specific scancode set?  </dd>
<dt><a class="anchor" id="_todo000493"></a>Member <a class="el" href="classX86StackFrame.html#a2fae4f4b173f8e27246694fe0fa0cb18">X86StackFrame::getParameter</a>  (size_t n)</dt>
<dd>better way to do this.  </dd>
<dt><a class="anchor" id="_todo000495"></a>Member <a class="el" href="classX86VirtualAddressSpace.html#a4018d1b0a9b7299967cd750c29d4c70a">X86VirtualAddressSpace::revertToKernelAddressSpace</a>  ()</dt>
<dd>When swap system comes along, we want to remove this page from swap!  </dd>
<dt><a class="anchor" id="_todo000594"></a>Member <a class="el" href="classXterm.html#af7510d64b701524b34cc92b850eaaa4f">Xterm::write</a>  (uint32_t utf32, <a class="el" href="classDirtyRectangle.html">DirtyRectangle</a> &amp;rect)</dt>
<dd><p class="startdd">Changes how title modes are set... </p>
<p>Do something about this. </p>
<p>Alternate keypad mode </p>
<p>In VT52 mode, we need to go into VT52 graphics mode... </p>
<p class="enddd">In VT52 mode, exit VT52 graphics mode... </p>
</dd>
</dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jan 24 2020 06:49:09 for The Pedigree Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
