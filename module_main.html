<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>The Pedigree Project: Module System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">The Pedigree Project
   &#160;<span id="projectnumber">0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="structModule.html">Module</a> System </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Pedigree's module system provides the foundation upon which all drivers and loadable system functionality are built. Modules can be loaded automatically at startup by inserting them into the system initrd, or they can be loaded after system startup via system calls. Modules can also be unloaded after system startup completes.</p>
<h1><a class="anchor" id="module_overview"></a>
Overview</h1>
<p>Pedigree modules are simply ELF object files that have not yet completed a final link stage. <a class="el" href="group__kernellinker.html">Pedigree's module loader</a> handles the final link when loading, fixing up symbol references against the kernel symbol table. This allows modules to use all symbols already available in the kernel. This also allows modules to use symbols defined by previously-loaded modules.</p>
<p>Each module provides functions to perform initialisation and termination, which are called by the kernel when the module is loaded and unloaded, respectively. Modules may also define dependencies, which must be loaded before attempting to load the module.</p>
<p>Modules are identified by a unique name, which is an ASCII string.</p>
<h1><a class="anchor" id="module_howto"></a>
Creating a Module</h1>
<p>The process for creating a module is fairly simple.</p>
<p>Firstly, determine whether or not the module is a driver or a system module. The distinction is not technically important, but modules in the repository are split between drivers and system modules. If the module is a driver, it belongs either in the 'common' directory, if architecture-independent, or in the relevant directory for the target architecture.</p>
<p>Create a module directory in the relevant place (as decided above), and create at a minimum a single C++ file that will define the basic requirements for the module.</p>
<p>In this C++ file, include <a class="el" href="Module_8h_source.html">Module.h</a> and invoke the <code>MODULE_INFO</code> macro. This macro defines the necessary metadata to allow the module to be loaded. </p><pre class="fragment">static bool example_entry() { return true; }
static void example_exit() {}
MODULE_INFO("example", example_entry, example_exit, "vfs", "init");
</pre><p>This will define a module "example", and call the <code>example_entry</code> function upon loading the module. The module will only be loaded once the "vfs" and "init" modules have been loaded. When the module is unloaded, the <code>example_exit</code> function will be called.</p>
<p>Note the fact that <code>example_entry</code> returns <code>bool</code>. Should the module entry function return <code>false</code>, the module is automatically unloaded. This is useful for drivers which do hardware detection as they can be removed from memory if the system does not have a particular piece of hardware.</p>
<h1><a class="anchor" id="module_static"></a>
Static Modules</h1>
<p>For some architectures, it makes more sense to build modules into the kernel rather than provide them in an initrd. For other architectures, the necessary support to load modules from an initrd has not yet been written. In these cases, <code>STATIC_DRIVERS</code> will be defined in the preprocessor. <a class="el" href="Module_8h_source.html">Module.h</a> already handles this case and <code>MODULE_INFO</code> will do the correct thing.</p>
<p>There should be essentially no difference to module code; it is not expected that <code>STATIC_DRIVERS</code> is a preprocessor definition that needs to be checked by module code. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jan 24 2020 06:49:09 for The Pedigree Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
