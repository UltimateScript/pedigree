<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>The Pedigree Project: RingBuffer&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">The Pedigree Project
   &#160;<span id="projectnumber">0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classRingBuffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RingBuffer&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Utility class to provide a ring buffer.  
 <a href="classRingBuffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="RingBuffer_8h_source.html">RingBuffer.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for RingBuffer&lt; T &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classRingBuffer__inherit__graph.png" border="0" usemap="#RingBuffer_3_01T_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="RingBuffer_3_01T_01_4_inherit__map" id="RingBuffer_3_01T_01_4_inherit__map">
<area shape="rect" id="node2" href="classRingBuffer.html" title="{RingBuffer\&lt; struct\l UnixSocket::buf * \&gt;\n|&#45; m_RingSize\l&#45; m_WriteCondition\l&#45; m_ReadCondition\l&#45; m_Ring\l&#45; m_Lock\l&#45; m_MonitorTargets\l|+ RingBuffer()\l+ RingBuffer()\l+ ~RingBuffer()\l+ write()\l+ write()\l+ write()\l+ write()\l+ read()\l+ read()\l+ read()\land 7 more...\l&#45; notifyMonitors()\l}" alt="" coords="5,395,147,721"/>
<area shape="rect" id="node3" href="classRingBuffer.html" title="{RingBuffer\&lt; void * \&gt;\n|&#45; m_RingSize\l&#45; m_WriteCondition\l&#45; m_ReadCondition\l&#45; m_Ring\l&#45; m_Lock\l&#45; m_MonitorTargets\l|+ RingBuffer()\l+ RingBuffer()\l+ ~RingBuffer()\l+ write()\l+ write()\l+ write()\l+ write()\l+ read()\l+ read()\l+ read()\land 7 more...\l&#45; notifyMonitors()\l}" alt="" coords="171,402,312,714"/>
</map>
</div>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for RingBuffer&lt; T &gt;:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classRingBuffer__coll__graph.png" border="0" usemap="#RingBuffer_3_01T_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="RingBuffer_3_01T_01_4_coll__map" id="RingBuffer_3_01T_01_4_coll__map">
<area shape="rect" id="node2" href="classList.html" title="{List\&lt; RingBuffer::Monitor\lTarget * \&gt;\n|&#45; m_Count\l&#45; m_Magic\l|+ List()\l+ List()\l+ ~List()\l+ operator=()\l+ size()\l+ count()\l+ pushBack()\l+ pushBack()\l+ popBack()\l+ pushFront()\land 14 more...\l}" alt="" coords="232,1817,400,2071"/>
<area shape="rect" id="node3" href="struct__ListNode__t.html" title="One node in the list. " alt="" coords="311,678,435,770"/>
<area shape="rect" id="node9" href="classVector.html" title="{Vector\&lt; _ListNode_t * \&gt;\n|&#45; m_Size\l&#45; m_Count\l&#45; m_Start\l&#45; m_ReserveFactor\l|+ Vector()\l+ Vector()\l+ Vector()\l+ ~Vector()\l+ operator=()\l+ operator[]()\l+ size()\l+ count()\l+ pushBack()\l+ popBack()\land 19 more...\l&#45; reserve()\l}" alt="" coords="495,957,657,1240"/>
<area shape="rect" id="node14" href="classList.html" title="{List\&lt; T, nodePoolSize \&gt;\n|&#45; m_Count\l&#45; m_Magic\l|+ List()\l+ List()\l+ ~List()\l+ operator=()\l+ size()\l+ count()\l+ pushBack()\l+ pushBack()\l+ popBack()\l+ pushFront()\land 14 more...\l}" alt="" coords="460,1516,623,1755"/>
<area shape="rect" id="node17" href="classList.html" title="{List\&lt; Thread * \&gt;\n|&#45; m_Count\l&#45; m_Magic\l|+ List()\l+ List()\l+ ~List()\l+ operator=()\l+ size()\l+ count()\l+ pushBack()\l+ pushBack()\l+ popBack()\l+ pushFront()\land 14 more...\l}" alt="" coords="459,1825,575,2063"/>
<area shape="rect" id="node21" href="classList.html" title="{List\&lt; class Thread * \&gt;\n|&#45; m_Count\l&#45; m_Magic\l|+ List()\l+ List()\l+ ~List()\l+ operator=()\l+ size()\l+ count()\l+ pushBack()\l+ pushBack()\l+ popBack()\l+ pushFront()\land 14 more...\l}" alt="" coords="933,1825,1083,2063"/>
<area shape="rect" id="node22" href="classList.html" title="{List\&lt; T \&gt;\n|&#45; m_Count\l&#45; m_Magic\l|+ List()\l+ List()\l+ ~List()\l+ operator=()\l+ size()\l+ count()\l+ pushBack()\l+ pushBack()\l+ popBack()\l+ pushFront()\land 14 more...\l}" alt="" coords="32,1825,139,2063"/>
<area shape="rect" id="node4" href="classObjectPool.html" title="{ObjectPool\&lt; _ListNode\l_t, 16 \&gt;\n||+ ObjectPool()\l+ ~ObjectPool()\l+ allocate()\l+ deallocate()\l}" alt="" coords="804,1567,961,1703"/>
<area shape="rect" id="node5" href="classSpinlock.html" title="{Spinlock\n|+ allow_recursion\l&#45; m_bInterrupts\l&#45; m_Sentinel\l&#45; m_Magic\l&#45; m_MagicAlign\l&#45; m_pOwner\l&#45; m_Level\l&#45; m_OwnedProcessor\l&#45; m_Ra\l&#45; m_bAvoidTracking\l&#45; m_bOwned\l|+ Spinlock()\l+ Spinlock()\l+ acquire()\l+ exit()\l+ release()\l+ acquired()\l+ interrupts()\l&#45; unwind()\l&#45; trackRelease()\l}" alt="" coords="1045,553,1193,895"/>
<area shape="rect" id="node12" href="classObjectPool.html" title="{ObjectPool\&lt; T, poolSize \&gt;\n||+ ObjectPool()\l+ ~ObjectPool()\l+ allocate()\l+ deallocate()\l}" alt="" coords="715,1038,891,1159"/>
<area shape="rect" id="node15" href="classObjectPool.html" title="{ObjectPool\&lt; _ListNode\l_t, nodePoolSize \&gt;\n||+ ObjectPool()\l+ ~ObjectPool()\l+ allocate()\l+ deallocate()\l}" alt="" coords="651,1317,808,1453"/>
<area shape="rect" id="node16" href="classConditionVariable.html" title="{ConditionVariable\n||+ ConditionVariable()\l+ ~ConditionVariable()\l+ wait()\l+ wait()\l+ signal()\l+ broadcast()\l}" alt="" coords="441,2170,593,2321"/>
<area shape="rect" id="node19" href="classSemaphore.html" title="{Semaphore\n|&#45; magic\l&#45; m_bCanInterrupt\l|+ Semaphore()\l+ ~Semaphore()\l+ acquireWithResult()\l+ acquire()\l+ tryAcquire()\l+ release()\l+ getValue()\l&#45; Semaphore()\l&#45; operator=()\l&#45; removeThread()\l}" alt="" coords="1125,2133,1275,2357"/>
<area shape="rect" id="node6" href="classAtomic.html" title="{Atomic\&lt; uint64_t \&gt;\n||}" alt="" coords="1199,248,1332,325"/>
<area shape="rect" id="node7" href="classAtomic.html" title="{Atomic\&lt; T, bAllow \&gt;\n||}" alt="" coords="1194,5,1337,83"/>
<area shape="rect" id="node8" href="classAtomic.html" title="{Atomic\&lt; bool \&gt;\n||}" alt="" coords="1063,248,1174,325"/>
<area shape="rect" id="node20" href="classAtomic.html" title="{Atomic\&lt; ssize_t \&gt;\n||}" alt="" coords="1307,452,1437,529"/>
<area shape="rect" id="node10" href="classVector.html" title="A vector / dynamic array. " alt="" coords="730,145,865,428"/>
<area shape="rect" id="node13" href="classVector.html" title="{Vector\&lt; T * \&gt;\n|&#45; m_Size\l&#45; m_Count\l&#45; m_Start\l&#45; m_ReserveFactor\l|+ Vector()\l+ Vector()\l+ Vector()\l+ ~Vector()\l+ operator=()\l+ operator[]()\l+ size()\l+ count()\l+ pushBack()\l+ popBack()\land 19 more...\l&#45; reserve()\l}" alt="" coords="730,583,865,865"/>
<area shape="rect" id="node18" href="classMutex.html" title="{Mutex\n||+ Mutex()\l+ ~Mutex()\l}" alt="" coords="755,2420,842,2512"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRingBuffer_1_1MonitorTarget.html">MonitorTarget</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a41f27bc91b14759673fa2521f9587fa7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41f27bc91b14759673fa2521f9587fa7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRingBuffer.html#a41f27bc91b14759673fa2521f9587fa7">RingBuffer</a> (size_t ringSize)</td></tr>
<tr class="memdesc:a41f27bc91b14759673fa2521f9587fa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor - pass in the desired size of the ring buffer. <br /></td></tr>
<tr class="separator:a41f27bc91b14759673fa2521f9587fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea502f6493ca669f07f9f01a4a94bdb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2ea502f6493ca669f07f9f01a4a94bdb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRingBuffer.html#a2ea502f6493ca669f07f9f01a4a94bdb">~RingBuffer</a> ()</td></tr>
<tr class="memdesc:a2ea502f6493ca669f07f9f01a4a94bdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor - destroys the ring; ensure nothing is calling waitFor. <br /></td></tr>
<tr class="separator:a2ea502f6493ca669f07f9f01a4a94bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0fb5c7798f179622eb6b73f041fe95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRingBuffer.html#a2f0fb5c7798f179622eb6b73f041fe95">write</a> (const T &amp;obj, Time::Timestamp &amp;timeout)</td></tr>
<tr class="memdesc:a2f0fb5c7798f179622eb6b73f041fe95"><td class="mdescLeft">&#160;</td><td class="mdescRight">write - write a byte to the ring buffer.  <a href="#a2f0fb5c7798f179622eb6b73f041fe95">More...</a><br /></td></tr>
<tr class="separator:a2f0fb5c7798f179622eb6b73f041fe95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93da463f199de888d8b63b432b3bcba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa93da463f199de888d8b63b432b3bcba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>write</b> (const T &amp;obj)</td></tr>
<tr class="separator:aa93da463f199de888d8b63b432b3bcba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a097d26849ac9034c25320714f74b6c68"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a097d26849ac9034c25320714f74b6c68"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRingBuffer.html#a097d26849ac9034c25320714f74b6c68">write</a> (const T *obj, size_t n, Time::Timestamp &amp;timeout)</td></tr>
<tr class="memdesc:a097d26849ac9034c25320714f74b6c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">write - write the given number of objects to the ring buffer. <br /></td></tr>
<tr class="separator:a097d26849ac9034c25320714f74b6c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25928f2ebb99cc72cc1afb7935e3db94"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25928f2ebb99cc72cc1afb7935e3db94"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>write</b> (const T *obj, size_t n)</td></tr>
<tr class="separator:a25928f2ebb99cc72cc1afb7935e3db94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a404a63ab677e244d13fabf3adfaf208a"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRingBuffer.html#a404a63ab677e244d13fabf3adfaf208a">read</a> (Time::Timestamp &amp;timeout)</td></tr>
<tr class="memdesc:a404a63ab677e244d13fabf3adfaf208a"><td class="mdescLeft">&#160;</td><td class="mdescRight">read - read a byte from the ring buffer.  <a href="#a404a63ab677e244d13fabf3adfaf208a">More...</a><br /></td></tr>
<tr class="separator:a404a63ab677e244d13fabf3adfaf208a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbbc01ec78046f316cc6997d209b2224"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abbbc01ec78046f316cc6997d209b2224"></a>
T&#160;</td><td class="memItemRight" valign="bottom"><b>read</b> ()</td></tr>
<tr class="separator:abbbc01ec78046f316cc6997d209b2224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c8c48844578a3f437917c96f4abd5e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad0c8c48844578a3f437917c96f4abd5e"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRingBuffer.html#ad0c8c48844578a3f437917c96f4abd5e">read</a> (T *out, size_t n, Time::Timestamp &amp;timeout)</td></tr>
<tr class="memdesc:ad0c8c48844578a3f437917c96f4abd5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">read - read up to the given number of objects from the ring buffer <br /></td></tr>
<tr class="separator:ad0c8c48844578a3f437917c96f4abd5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8011385a8a1eac6d0e1b3787907b7c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d8011385a8a1eac6d0e1b3787907b7c"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>read</b> (T *out, size_t n)</td></tr>
<tr class="separator:a1d8011385a8a1eac6d0e1b3787907b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5184c0e142718c88475125bde14bd06"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5184c0e142718c88475125bde14bd06"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRingBuffer.html#af5184c0e142718c88475125bde14bd06">dataReady</a> ()</td></tr>
<tr class="memdesc:af5184c0e142718c88475125bde14bd06"><td class="mdescLeft">&#160;</td><td class="mdescRight">dataReady - is data ready for reading from the ring buffer? <br /></td></tr>
<tr class="separator:af5184c0e142718c88475125bde14bd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3405b55741e1b9a73e286bb3c19ee045"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3405b55741e1b9a73e286bb3c19ee045"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRingBuffer.html#a3405b55741e1b9a73e286bb3c19ee045">canWrite</a> ()</td></tr>
<tr class="memdesc:a3405b55741e1b9a73e286bb3c19ee045"><td class="mdescLeft">&#160;</td><td class="mdescRight">canWrite - is it possible to write to the ring buffer without blocking? <br /></td></tr>
<tr class="separator:a3405b55741e1b9a73e286bb3c19ee045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8ef32e2be6250ceb93f4a4584bed3f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adb8ef32e2be6250ceb93f4a4584bed3f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRingBuffer.html#adb8ef32e2be6250ceb93f4a4584bed3f">waitFor</a> (RingBufferWait::WaitType wait, Time::Timestamp &amp;timeout)</td></tr>
<tr class="memdesc:adb8ef32e2be6250ceb93f4a4584bed3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">waitFor - block until the given condition is true (readable/writeable) <br /></td></tr>
<tr class="separator:adb8ef32e2be6250ceb93f4a4584bed3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a96b40cf636c24061b3b7710f313e35"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a96b40cf636c24061b3b7710f313e35"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>waitFor</b> (RingBufferWait::WaitType wait)</td></tr>
<tr class="separator:a5a96b40cf636c24061b3b7710f313e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b158963510552cb0d8443fa6b944d35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRingBuffer.html#a6b158963510552cb0d8443fa6b944d35">monitor</a> (<a class="el" href="classThread.html">Thread</a> *pThread, <a class="el" href="classEvent.html">Event</a> *pEvent)</td></tr>
<tr class="memdesc:a6b158963510552cb0d8443fa6b944d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">monitor - add a new <a class="el" href="classEvent.html">Event</a> to be fired when something happens  <a href="#a6b158963510552cb0d8443fa6b944d35">More...</a><br /></td></tr>
<tr class="separator:a6b158963510552cb0d8443fa6b944d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e411021b1de4834c00c7dbf11bc4ff8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7e411021b1de4834c00c7dbf11bc4ff8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRingBuffer.html#a7e411021b1de4834c00c7dbf11bc4ff8">cullMonitorTargets</a> (<a class="el" href="classThread.html">Thread</a> *pThread)</td></tr>
<tr class="memdesc:a7e411021b1de4834c00c7dbf11bc4ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cull all monitor targets pointing to <code>pThread</code>. <br /></td></tr>
<tr class="separator:a7e411021b1de4834c00c7dbf11bc4ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a83d1c4bfed1021e5b71baa0d1ac1ddac"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83d1c4bfed1021e5b71baa0d1ac1ddac"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRingBuffer.html#a83d1c4bfed1021e5b71baa0d1ac1ddac">notifyMonitors</a> ()</td></tr>
<tr class="memdesc:a83d1c4bfed1021e5b71baa0d1ac1ddac"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structTrigger.html">Trigger</a> event for threads waiting on us. <br /></td></tr>
<tr class="separator:a83d1c4bfed1021e5b71baa0d1ac1ddac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a7d45a44fe925ad2f2b57afd3b63e47ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d45a44fe925ad2f2b57afd3b63e47ad"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>m_RingSize</b></td></tr>
<tr class="separator:a7d45a44fe925ad2f2b57afd3b63e47ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3976644c1162ba1bd4f393a68534dd46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3976644c1162ba1bd4f393a68534dd46"></a>
<a class="el" href="classConditionVariable.html">ConditionVariable</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_WriteCondition</b></td></tr>
<tr class="separator:a3976644c1162ba1bd4f393a68534dd46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8aea4a0c24933ed1d1f91841ee59097"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8aea4a0c24933ed1d1f91841ee59097"></a>
<a class="el" href="classConditionVariable.html">ConditionVariable</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_ReadCondition</b></td></tr>
<tr class="separator:af8aea4a0c24933ed1d1f91841ee59097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabcd1e4aafc2bfc6875897b8f90ecd30"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aabcd1e4aafc2bfc6875897b8f90ecd30"></a>
<a class="el" href="classList.html">List</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_Ring</b></td></tr>
<tr class="separator:aabcd1e4aafc2bfc6875897b8f90ecd30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa885d44835c70e2a81daf4121e65d905"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa885d44835c70e2a81daf4121e65d905"></a>
<a class="el" href="classMutex.html">Mutex</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_Lock</b></td></tr>
<tr class="separator:aa885d44835c70e2a81daf4121e65d905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6871412f214f32762cc08bfaaaf53e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe6871412f214f32762cc08bfaaaf53e"></a>
<a class="el" href="classList.html">List</a>&lt; <a class="el" href="structRingBuffer_1_1MonitorTarget.html">MonitorTarget</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_MonitorTargets</b></td></tr>
<tr class="separator:afe6871412f214f32762cc08bfaaaf53e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class RingBuffer&lt; T &gt;</h3>

<p>Utility class to provide a ring buffer. </p>
<p>Using this class provides safety in accessing the ring buffer as well as the ability to check (with and without blocking) whether the buffer can be read or written to at this time.</p>
<p>The idea of the waitFor function is to provide a way for applications desiring integration with a select()-style interface to block until the condition is met. </p>

<p>Definition at line <a class="el" href="RingBuffer_8h_source.html#l00061">61</a> of file <a class="el" href="RingBuffer_8h_source.html">RingBuffer.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a6b158963510552cb0d8443fa6b944d35"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRingBuffer.html">RingBuffer</a>&lt; T &gt;::monitor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classThread.html">Thread</a> *&#160;</td>
          <td class="paramname"><em>pThread</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classEvent.html">Event</a> *&#160;</td>
          <td class="paramname"><em>pEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>monitor - add a new <a class="el" href="classEvent.html">Event</a> to be fired when something happens </p>
<p>This could be a read or a write event; after receiving the event be sure to call <a class="el" href="classRingBuffer.html#af5184c0e142718c88475125bde14bd06" title="dataReady - is data ready for reading from the ring buffer? ">dataReady()</a> and/or <a class="el" href="classRingBuffer.html#a3405b55741e1b9a73e286bb3c19ee045" title="canWrite - is it possible to write to the ring buffer without blocking? ">canWrite()</a> to determine the state of the buffer.</p>
<p>Do not assume that an event means both a read and write will not block. In fact, never assume an event means either will not block. You may need to re-subscribe to the event if something else reads or writes to the ring buffer between the event trigger and your handling. </p>

<p>Definition at line <a class="el" href="RingBuffer_8h_source.html#l00280">280</a> of file <a class="el" href="RingBuffer_8h_source.html">RingBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a404a63ab677e244d13fabf3adfaf208a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classRingBuffer.html">RingBuffer</a>&lt; T &gt;::read </td>
          <td>(</td>
          <td class="paramtype">Time::Timestamp &amp;&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>read - read a byte from the ring buffer. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000408">Todo:</a></b></dt><dd>need to allow read() to fail - use Result&lt;&gt; </dd></dl>

<p>Definition at line <a class="el" href="RingBuffer_8h_source.html#l00138">138</a> of file <a class="el" href="RingBuffer_8h_source.html">RingBuffer.h</a>.</p>

</div>
</div>
<a class="anchor" id="a2f0fb5c7798f179622eb6b73f041fe95"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classRingBuffer.html">RingBuffer</a>&lt; T &gt;::write </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Time::Timestamp &amp;&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>write - write a byte to the ring buffer. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000407">Todo:</a></b></dt><dd>oh dear, writes are always assumed to succeed </dd></dl>

<p>Definition at line <a class="el" href="RingBuffer_8h_source.html#l00079">79</a> of file <a class="el" href="RingBuffer_8h_source.html">RingBuffer.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="RingBuffer_8h_source.html">RingBuffer.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jan 24 2020 06:49:12 for The Pedigree Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
